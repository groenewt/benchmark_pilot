{
  "schema": "ai",
  "database": "rag_db",
  "extraction_timestamp": "NOW()",
  "functions": [
    {
      "oid": 18931,
      "name": "_evaluate_destination",
      "definition": "CREATE OR REPLACE FUNCTION ai._evaluate_destination(destination jsonb, source_schema name, source_table name)\n RETURNS jsonb\n LANGUAGE plpgsql\n STABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    target_schema pg_catalog.name;\n    target_table pg_catalog.name;\n    view_schema pg_catalog.name;\n    view_name pg_catalog.name;\nbegin\n    if destination operator(pg_catalog.->>) 'implementation' = 'table' then\n        target_schema = coalesce(destination operator(pg_catalog.->>) 'target_schema', source_schema);\n        target_table = case\n            when destination operator(pg_catalog.->>) 'target_table' is not null then destination operator(pg_catalog.->>) 'target_table'\n            when destination operator(pg_catalog.->>) 'destination' is not null then pg_catalog.concat(destination operator(pg_catalog.->>) 'destination', '_store')\n            else pg_catalog.concat(source_table, '_embedding_store')\n        end;\n        view_schema = coalesce(view_schema, source_schema);\n        view_name = case\n            when destination operator(pg_catalog.->>) 'view_name' is not null then destination operator(pg_catalog.->>) 'view_name'\n            when destination operator(pg_catalog.->>) 'destination' is not null then destination operator(pg_catalog.->>) 'destination'\n            else pg_catalog.concat(source_table, '_embedding')\n        end;\n        return json_build_object\n        ( 'implementation', 'table'\n        , 'config_type', 'destination'\n        , 'target_schema', target_schema\n        , 'target_table', target_table\n        , 'view_schema', view_schema\n        , 'view_name', view_name\n        );\n    elseif destination operator(pg_catalog.->>) 'implementation' = 'column' then\n        return json_build_object\n        ( 'implementation', 'column'\n        , 'config_type', 'destination'\n        , 'embedding_column', destination operator(pg_catalog.->>) 'embedding_column'\n        );\n    else\n        raise exception 'invalid implementation for destination config';\n    end if;\nend\n$function$\n",
      "description": null,
      "arguments": "destination jsonb, source_schema name, source_table name",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "s",
      "volatility_label": "stable",
      "language": "plpgsql"
    },
    {
      "oid": 18911,
      "name": "_resolve_indexing_default",
      "definition": "CREATE OR REPLACE FUNCTION ai._resolve_indexing_default()\n RETURNS jsonb\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _setting pg_catalog.text;\nbegin\n    select pg_catalog.current_setting('ai.indexing_default', true) into _setting;\n    case _setting\n        when 'indexing_diskann' then\n            return ai.indexing_diskann();\n        when 'indexing_hnsw' then\n            return ai.indexing_hnsw();\n        else\n            return ai.indexing_none();\n    end case;\nend;\n$function$\n",
      "description": null,
      "arguments": "",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18901,
      "name": "_resolve_scheduling_default",
      "definition": "CREATE OR REPLACE FUNCTION ai._resolve_scheduling_default()\n RETURNS jsonb\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _setting pg_catalog.text;\nbegin\n    select pg_catalog.current_setting('ai.scheduling_default', true) into _setting;\n    case _setting\n        when 'scheduling_timescaledb' then\n            return ai.scheduling_timescaledb();\n        else\n            return ai.scheduling_none();\n    end case;\nend;\n$function$\n",
      "description": null,
      "arguments": "",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18982,
      "name": "_sc_obj",
      "definition": "CREATE OR REPLACE FUNCTION ai._sc_obj(catalog_id integer)\n RETURNS TABLE(id bigint, classid oid, objid oid, objsubid integer, objtype text, objnames text[], objargs text[], description text)\n LANGUAGE plpgsql\n STABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _sql text;\nbegin\n    _sql = format\n    ( $sql$\n        select\n          id\n        , classid\n        , objid\n        , objsubid\n        , objtype\n        , objnames\n        , objargs\n        , description\n        from ai.semantic_catalog_obj_%s\n      $sql$\n    , catalog_id\n    );\n    return query execute _sql;\nend\n$function$\n",
      "description": null,
      "arguments": "catalog_id integer",
      "return_type": "TABLE(id bigint, classid oid, objid oid, objsubid integer, objtype text, objnames text[], objargs text[], description text)",
      "kind": "f",
      "kind_label": "function",
      "volatility": "s",
      "volatility_label": "stable",
      "language": "plpgsql"
    },
    {
      "oid": 18974,
      "name": "_semantic_catalog_make_triggers",
      "definition": "CREATE OR REPLACE FUNCTION ai._semantic_catalog_make_triggers(semantic_catalog_id integer)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n/*\nthis function dynamically creates triggers on the obj, sql, and fact tables associated with a\nsemantic catalog. if any non-vector columns are updated, the vector columns are nulled out by\nthese triggers. this serves as the signal that the row should be reembedded\n*/\ndeclare\n    _tbl text;\n    _sql text;\n    _vec_type oid;\n    _vec_nulls text;\n    _col_diffs text;\nbegin\n    -- find the oid of the vector data type\n    select y.oid into strict _vec_type\n    from pg_type y\n    inner join pg_depend d on (y.oid = d.objid)\n    inner join pg_extension x on (x.oid = d.refobjid)\n    where d.classid = 'pg_catalog.pg_type'::regclass::oid\n    and d.refclassid = 'pg_catalog.pg_extension'::regclass::oid\n    and d.deptype = 'e'\n    and x.extname = 'vector'\n    and y.typname = 'vector'\n    ;\n\n    foreach _tbl in array array['obj', 'sql', 'fact']\n    loop\n        select string_agg\n        (\n          format\n          ( $sql$new.%s = null;$sql$\n          , a.attname\n          )\n        , E'\\n        '\n        order by a.attnum\n        ) filter (where a.atttypid = _vec_type)\n        , string_agg\n        (\n          format\n          ( $sql$(old.%s != new.%s)$sql$\n          , a.attname\n          , a.attname\n          )\n        , E'\\n    or '\n        order by a.attnum\n        ) filter (where a.atttypid != _vec_type)\n        into strict \n          _vec_nulls\n        , _col_diffs\n        from pg_class k\n        inner join pg_namespace n on (k.relnamespace = n.oid)\n        inner join pg_attribute a on (k.oid = a.attrelid)\n        where n.nspname = 'ai'\n        and k.relname = format('semantic_catalog_%s_%s', _tbl, semantic_catalog_id)\n        and a.attnum > 0\n        and not a.attisdropped\n        ;\n        \n        _sql = format(regexp_replace(\n        $sql$\n        create or replace function ai.semantic_catalog_%s_%s_trig() returns trigger\n        as $trigger$\n        declare\n        begin\n            if tg_op = 'UPDATE' and\n            (  %s\n            )\n            then\n                %s\n            end if;\n            return new;\n        end\n        $trigger$ language plpgsql volatile security invoker\n        set search_path to pg_catalog, pg_temp\n        $sql$, '^ {8}', '', 'gm') -- dedent 8 spaces\n        , _tbl\n        , semantic_catalog_id\n        , _col_diffs\n        , _vec_nulls\n        );\n        raise debug '%', _sql;\n        execute _sql;\n        \n        perform\n        from pg_class k\n        inner join pg_namespace n on (k.relnamespace = n.oid)\n        inner join pg_trigger g on (g.tgrelid = k.oid)\n        where n.nspname = 'ai'\n        and k.relname = format('semantic_catalog_%s_%s', _tbl, semantic_catalog_id)\n        and g.tgname = format('semantic_catalog_%s_%s_trig', _tbl, semantic_catalog_id)\n        ;\n        if not found then\n            _sql = format(regexp_replace(\n            $sql$\n            create trigger semantic_catalog_%s_%s_trig \n            before update on ai.semantic_catalog_%s_%s\n            for each row\n            execute function ai.semantic_catalog_%s_%s_trig()\n            $sql$, '^ {12}', '', 'gm') -- dedent 12 spaces\n            , _tbl\n            , semantic_catalog_id\n            , _tbl\n            , semantic_catalog_id\n            , _tbl\n            , semantic_catalog_id\n            );\n            raise debug '%', _sql;\n            execute _sql;\n        end if;\n    end loop;\nend\n$function$\n",
      "description": null,
      "arguments": "semantic_catalog_id integer",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18894,
      "name": "_validate_chunking",
      "definition": "CREATE OR REPLACE FUNCTION ai._validate_chunking(config jsonb)\n RETURNS void\n LANGUAGE plpgsql\n STABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _config_type pg_catalog.text;\n    _implementation pg_catalog.text;\nbegin\n    if pg_catalog.jsonb_typeof(config) operator(pg_catalog.!=) 'object' then\n        raise exception 'chunking config is not a jsonb object';\n    end if;\n\n    _config_type = config operator(pg_catalog.->>) 'config_type';\n    if _config_type is null or _config_type operator(pg_catalog.!=) 'chunking' then\n        raise exception 'invalid config_type for chunking config';\n    end if;\n\n    _implementation = config operator(pg_catalog.->>) 'implementation';\n    if _implementation is null or _implementation not in ('character_text_splitter', 'recursive_character_text_splitter', 'none') then\n        raise exception 'invalid chunking config implementation';\n    end if;\nend\n$function$\n",
      "description": null,
      "arguments": "config jsonb",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "s",
      "volatility_label": "stable",
      "language": "plpgsql"
    },
    {
      "oid": 18930,
      "name": "_validate_destination",
      "definition": "CREATE OR REPLACE FUNCTION ai._validate_destination(destination jsonb, chunking jsonb)\n RETURNS void\n LANGUAGE plpgsql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _config_type pg_catalog.text;\nbegin\n    if pg_catalog.jsonb_typeof(destination) operator(pg_catalog.!=) 'object' then\n        raise exception 'destination config is not a jsonb object';\n    end if;\n\n    _config_type = destination operator(pg_catalog.->>) 'config_type';\n    if _config_type is null or _config_type operator(pg_catalog.!=) 'destination' then\n        raise exception 'invalid config_type for destination config';\n    end if;\n\n    if destination->>'implementation' = 'column' then\n        if chunking->>'implementation' != 'none' then\n            raise exception 'chunking must be none for column destination';\n        end if;\n    end if;\nend\n$function$\n",
      "description": null,
      "arguments": "destination jsonb, chunking jsonb",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpgsql"
    },
    {
      "oid": 18932,
      "name": "_validate_destination_can_create_objects",
      "definition": "CREATE OR REPLACE FUNCTION ai._validate_destination_can_create_objects(destination jsonb)\n RETURNS void\n LANGUAGE plpgsql\n STABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _config_type pg_catalog.text;\nbegin\n    if destination operator(pg_catalog.->>) 'implementation' = 'table' then\n         -- make sure view name is available\n        if pg_catalog.to_regclass(pg_catalog.format('%I.%I', destination operator(pg_catalog.->>) 'view_schema', destination operator(pg_catalog.->>) 'view_name')) is not null then\n            raise exception 'an object named %.% already exists. specify an alternate destination or view_name explicitly', destination operator(pg_catalog.->>) 'view_schema', destination operator(pg_catalog.->>) 'view_name'\n            using errcode = 'duplicate_object';\n        end if;\n    \n        -- make sure target table name is available\n        if pg_catalog.to_regclass(pg_catalog.format('%I.%I', destination operator(pg_catalog.->>) 'target_schema', destination operator(pg_catalog.->>) 'target_table')) is not null then\n            raise exception 'an object named %.% already exists. specify an alternate destination or target_table explicitly', destination operator(pg_catalog.->>) 'target_schema', destination operator(pg_catalog.->>) 'target_table'\n            using errcode = 'duplicate_object';\n        end if;\n    end if;\nend\n$function$\n",
      "description": null,
      "arguments": "destination jsonb",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "s",
      "volatility_label": "stable",
      "language": "plpgsql"
    },
    {
      "oid": 18907,
      "name": "_validate_embedding",
      "definition": "CREATE OR REPLACE FUNCTION ai._validate_embedding(config jsonb)\n RETURNS void\n LANGUAGE plpgsql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _config_type pg_catalog.text;\n    _implementation pg_catalog.text;\nbegin\n    if pg_catalog.jsonb_typeof(config) operator(pg_catalog.!=) 'object' then\n        raise exception 'embedding config is not a jsonb object';\n    end if;\n\n    _config_type = config operator(pg_catalog.->>) 'config_type';\n    if _config_type is null or _config_type operator(pg_catalog.!=) 'embedding' then\n        raise exception 'invalid config_type for embedding config';\n    end if;\n    _implementation = config operator(pg_catalog.->>) 'implementation';\n    case _implementation\n        when 'openai' then\n            -- ok\n        when 'ollama' then\n            -- ok\n        when 'voyageai' then\n            -- ok\n        when 'litellm' then\n            -- ok\n        else\n            if _implementation is null then\n                raise exception 'embedding implementation not specified';\n            else\n                raise exception 'invalid embedding implementation: \"%\"', _implementation;\n            end if;\n    end case;\nend\n$function$\n",
      "description": null,
      "arguments": "config jsonb",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpgsql"
    },
    {
      "oid": 18897,
      "name": "_validate_formatting",
      "definition": "CREATE OR REPLACE FUNCTION ai._validate_formatting(config jsonb, source_schema name, source_table name)\n RETURNS void\n LANGUAGE plpgsql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _config_type pg_catalog.text;\nbegin\n    if pg_catalog.jsonb_typeof(config) != 'object' then\n        raise exception 'formatting config is not a jsonb object';\n    end if;\n\n    _config_type = config operator ( pg_catalog.->> ) 'config_type';\n    if _config_type is null or _config_type operator(pg_catalog.!=) 'formatting' then\n        raise exception 'invalid config_type for formatting config';\n    end if;\n    case config operator(pg_catalog.->>) 'implementation'\n        when 'python_template' then\n            perform ai._validate_formatting_python_template\n            ( config\n            , source_schema\n            , source_table\n            );\n        else\n            raise exception 'unrecognized formatting implementation';\n    end case;\nend\n$function$\n",
      "description": null,
      "arguments": "config jsonb, source_schema name, source_table name",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpgsql"
    },
    {
      "oid": 18896,
      "name": "_validate_formatting_python_template",
      "definition": "CREATE OR REPLACE FUNCTION ai._validate_formatting_python_template(config jsonb, source_schema name, source_table name)\n RETURNS void\n LANGUAGE plpgsql\n STABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _template pg_catalog.text;\n    _found pg_catalog.bool;\nbegin\n    select config operator(pg_catalog.->>) 'template'\n    into strict _template\n    ;\n    if not pg_catalog.like(_template, '%$chunk%') then\n        raise exception 'template must contain $chunk placeholder';\n    end if;\n\n    -- check that no columns on the source table are named \"chunk\"\n    select count(*) operator(pg_catalog.>) 0 into strict _found\n    from pg_catalog.pg_class k\n    inner join pg_catalog.pg_namespace n on (k.relnamespace = n.oid)\n    inner join pg_catalog.pg_attribute a on (k.oid = a.attrelid)\n    where n.nspname operator(pg_catalog.=) source_schema\n    and k.relname operator(pg_catalog.=) source_table\n    and a.attnum operator(pg_catalog.>) 0\n    and a.attname operator(pg_catalog.=) 'chunk'\n    ;\n    if _found then\n        raise exception 'formatting_python_template may not be used when source table has a column named \"chunk\"';\n    end if;\nend\n$function$\n",
      "description": null,
      "arguments": "config jsonb, source_schema name, source_table name",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "s",
      "volatility_label": "stable",
      "language": "plpgsql"
    },
    {
      "oid": 18915,
      "name": "_validate_indexing",
      "definition": "CREATE OR REPLACE FUNCTION ai._validate_indexing(config jsonb)\n RETURNS void\n LANGUAGE plpgsql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _config_type pg_catalog.text;\n    _implementation pg_catalog.text;\nbegin\n    if pg_catalog.jsonb_typeof(config) operator(pg_catalog.!=) 'object' then\n        raise exception 'indexing config is not a jsonb object';\n    end if;\n\n    _config_type = config operator(pg_catalog.->>) 'config_type';\n    if _config_type is null or _config_type operator(pg_catalog.!=) 'indexing' then\n        raise exception 'invalid config_type for indexing config';\n    end if;\n    _implementation = config operator(pg_catalog.->>) 'implementation';\n    case _implementation\n        when 'none' then\n            -- ok\n        when 'diskann' then\n            perform ai._validate_indexing_diskann(config);\n        when 'hnsw' then\n            perform ai._validate_indexing_hnsw(config);\n        else\n            if _implementation is null then\n                raise exception 'indexing implementation not specified';\n            else\n                raise exception 'invalid indexing implementation: \"%\"', _implementation;\n            end if;\n    end case;\nend\n$function$\n",
      "description": null,
      "arguments": "config jsonb",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpgsql"
    },
    {
      "oid": 18912,
      "name": "_validate_indexing_diskann",
      "definition": "CREATE OR REPLACE FUNCTION ai._validate_indexing_diskann(config jsonb)\n RETURNS void\n LANGUAGE plpgsql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _storage_layout pg_catalog.text;\nbegin\n    _storage_layout = config operator(pg_catalog.->>) 'storage_layout';\n    if _storage_layout is not null and not (_storage_layout operator(pg_catalog.=) any(array['memory_optimized', 'plain'])) then\n        raise exception 'invalid storage_layout';\n    end if;\nend\n$function$\n",
      "description": null,
      "arguments": "config jsonb",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpgsql"
    },
    {
      "oid": 18914,
      "name": "_validate_indexing_hnsw",
      "definition": "CREATE OR REPLACE FUNCTION ai._validate_indexing_hnsw(config jsonb)\n RETURNS void\n LANGUAGE plpgsql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _opclass pg_catalog.text;\nbegin\n    _opclass = config operator(pg_catalog.->>) 'opclass';\n    if _opclass is not null\n    and not (_opclass operator(pg_catalog.=) any(array['vector_ip_ops', 'vector_cosine_ops', 'vector_l1_ops'])) then\n        raise exception 'invalid opclass';\n    end if;\nend\n$function$\n",
      "description": null,
      "arguments": "config jsonb",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpgsql"
    },
    {
      "oid": 18922,
      "name": "_validate_loading",
      "definition": "CREATE OR REPLACE FUNCTION ai._validate_loading(config jsonb, source_schema name, source_table name)\n RETURNS void\n LANGUAGE plpgsql\n STABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _config_type pg_catalog.text;\n    _implementation pg_catalog.text;\n    _column_name pg_catalog.name;\n    _found pg_catalog.bool;\n    _column_type pg_catalog.text;\nbegin\n    if pg_catalog.jsonb_typeof(config) operator(pg_catalog.!=) 'object' then\n        raise exception 'loading config is not a jsonb object';\nend if;\n\n    _config_type = config operator(pg_catalog.->>) 'config_type';\n    if _config_type is null or _config_type operator(pg_catalog.!=) 'loading' then\n        raise exception 'invalid config_type for loading config';\nend if;\n\n    _implementation = config operator(pg_catalog.->>) 'implementation';\n    if _implementation is null or _implementation not in ('column', 'uri') then\n        raise exception 'invalid loading config implementation';\nend if;\n\n    _column_name = config operator(pg_catalog.->>) 'column_name';\n     if _column_name is null then\n        raise exception 'invalid loading config, missing column_name';\nend if;\n\n    if (config operator(pg_catalog.->>) 'retries') is null or (config operator(pg_catalog.->>) 'retries')::int < 0 then\n        raise exception 'invalid loading config, retries must be a non-negative integer';\nend if;\n    if (config operator(pg_catalog.->>) 'aws_role_arn') is not null and (config operator(pg_catalog.->>) 'aws_role_arn') not like 'arn:aws:iam::%:role/%' then\n        raise exception 'invalid loading config, aws_role_arn must match arn:aws:iam::*:role/*';\nend if;\n\n    select y.typname into _column_type\n    from pg_catalog.pg_class k\n        inner join pg_catalog.pg_namespace n on (k.relnamespace operator(pg_catalog.=) n.oid)\n        inner join pg_catalog.pg_attribute a on (k.oid operator(pg_catalog.=) a.attrelid)\n        inner join pg_catalog.pg_type y on (a.atttypid operator(pg_catalog.=) y.oid)\n    where n.nspname operator(pg_catalog.=) source_schema\n        and k.relname operator(pg_catalog.=) source_table\n        and a.attnum operator(pg_catalog.>) 0\n        and a.attname operator(pg_catalog.=) _column_name\n        and not a.attisdropped;\n\n    if _column_type is null then\n            raise exception 'column_name in config does not exist in the table: %', _column_name;\n    end if;\n\n    if _column_type not in ('text', 'varchar', 'char', 'bpchar', 'bytea') then\n            raise exception 'column_name % in config is of invalid type %. Supported types are: text, varchar, char, bpchar, bytea', _column_name, _column_type;\n    end if;\n\n    if _implementation = 'uri' and _column_type not in ('text', 'varchar', 'char', 'bpchar') then\n        raise exception 'the type of the column `%` in config is not compatible with `uri` loading '\n       'implementation (type should be either text, varchar, char, bpchar, or bytea)', _column_name;\n    end if;\nend\n$function$\n",
      "description": null,
      "arguments": "config jsonb, source_schema name, source_table name",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "s",
      "volatility_label": "stable",
      "language": "plpgsql"
    },
    {
      "oid": 18927,
      "name": "_validate_parsing",
      "definition": "CREATE OR REPLACE FUNCTION ai._validate_parsing(parsing jsonb, loading jsonb, source_schema name, source_table name)\n RETURNS void\n LANGUAGE plpgsql\n STABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _column_type pg_catalog.name;\n    _config_type pg_catalog.text;\n    _loading_implementation pg_catalog.text;\n    _parsing_implementation pg_catalog.text;\nbegin\n    -- Basic structure validation\n    if pg_catalog.jsonb_typeof(parsing) operator(pg_catalog.!=) 'object' then\n        raise exception 'parsing config is not a jsonb object';\n    end if;\n\n    -- Validate config_type\n    _config_type = parsing operator(pg_catalog.->>) 'config_type';\n    if _config_type is null or _config_type operator(pg_catalog.!=) 'parsing' then\n        raise exception 'invalid config_type for parsing config';\n    end if;\n\n    -- Get implementations\n    _loading_implementation = loading operator(pg_catalog.->>) 'implementation';\n    -- Skip validation of loading implementation since it's done in _validate_loading\n\n    _parsing_implementation = parsing operator(pg_catalog.->>) 'implementation';\n    if _parsing_implementation not in ('auto', 'none', 'pymupdf', 'docling') then\n        raise exception 'invalid parsing config implementation';\n    end if;\n\n    -- Get the column type once\n    select y.typname \n    into _column_type\n    from pg_catalog.pg_class k\n        inner join pg_catalog.pg_namespace n on (k.relnamespace operator(pg_catalog.=) n.oid)\n        inner join pg_catalog.pg_attribute a on (k.oid operator(pg_catalog.=) a.attrelid)\n        inner join pg_catalog.pg_type y on (a.atttypid operator(pg_catalog.=) y.oid)\n    where n.nspname operator(pg_catalog.=) source_schema\n    and k.relname operator(pg_catalog.=) source_table\n    and a.attnum operator(pg_catalog.>) 0\n    and a.attname operator(pg_catalog.=) (loading operator(pg_catalog.->>) 'column_name');\n\n    -- Validate all combinations\n    if _parsing_implementation = 'none' and _column_type = 'bytea' then\n        raise exception 'cannot use parsing_none with bytea columns';\n    end if;\n\n    if _loading_implementation = 'column' and _parsing_implementation in ('pymupdf', 'docling')\n       and _column_type != 'bytea' then\n        raise exception 'parsing_% must be used with a bytea column', _parsing_implementation;\n    end if;\n\nend\n$function$\n",
      "description": null,
      "arguments": "parsing jsonb, loading jsonb, source_schema name, source_table name",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "s",
      "volatility_label": "stable",
      "language": "plpgsql"
    },
    {
      "oid": 18917,
      "name": "_validate_processing",
      "definition": "CREATE OR REPLACE FUNCTION ai._validate_processing(config jsonb)\n RETURNS void\n LANGUAGE plpgsql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _config_type pg_catalog.text;\n    _implementation pg_catalog.text;\n    _val pg_catalog.jsonb;\nbegin\n    if pg_catalog.jsonb_typeof(config) operator(pg_catalog.!=) 'object' then\n        raise exception 'processing config is not a jsonb object';\n    end if;\n\n    _config_type = config operator(pg_catalog.->>) 'config_type';\n    if _config_type is null or _config_type operator(pg_catalog.!=) 'processing' then\n        raise exception 'invalid config_type for processing config';\n    end if;\n    _implementation = config operator(pg_catalog.->>) 'implementation';\n    case _implementation\n        when 'default' then\n            _val = pg_catalog.jsonb_extract_path(config, 'batch_size');\n            if _val is not null then\n                if pg_catalog.jsonb_typeof(_val) operator(pg_catalog.!=) 'number' then\n                    raise exception 'batch_size must be a number';\n                end if;\n                if cast(_val as pg_catalog.int4) operator(pg_catalog.>) 2048 then\n                    raise exception 'batch_size must be less than or equal to 2048';\n                end if;\n                if cast(_val as pg_catalog.int4) operator(pg_catalog.<) 1 then\n                    raise exception 'batch_size must be greater than 0';\n                end if;\n            end if;\n\n            _val = pg_catalog.jsonb_extract_path(config, 'concurrency');\n            if _val is not null then\n                if pg_catalog.jsonb_typeof(_val) operator(pg_catalog.!=) 'number' then\n                    raise exception 'concurrency must be a number';\n                end if;\n                if cast(_val as pg_catalog.int4) operator(pg_catalog.>) 50 then\n                    raise exception 'concurrency must be less than or equal to 50';\n                end if;\n                if cast(_val as pg_catalog.int4) operator(pg_catalog.<) 1 then\n                    raise exception 'concurrency must be greater than 0';\n                end if;\n            end if;\n        else\n            if _implementation is null then\n                raise exception 'processing implementation not specified';\n            else\n                raise exception 'unrecognized processing implementation: \"%\"', _implementation;\n            end if;\n    end case;\nend\n$function$\n",
      "description": null,
      "arguments": "config jsonb",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpgsql"
    },
    {
      "oid": 18902,
      "name": "_validate_scheduling",
      "definition": "CREATE OR REPLACE FUNCTION ai._validate_scheduling(config jsonb)\n RETURNS void\n LANGUAGE plpgsql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _config_type pg_catalog.text;\n    _implementation pg_catalog.text;\nbegin\n    if pg_catalog.jsonb_typeof(config) operator(pg_catalog.!=) 'object' then\n        raise exception 'scheduling config is not a jsonb object';\n    end if;\n\n    _config_type = config operator(pg_catalog.->>) 'config_type';\n    if _config_type is null or _config_type operator(pg_catalog.!=) 'scheduling' then\n        raise exception 'invalid config_type for scheduling config';\n    end if;\n    _implementation = config operator(pg_catalog.->>) 'implementation';\n    case _implementation\n        when 'none' then\n            -- ok\n        when 'timescaledb' then\n            -- ok\n        else\n            if _implementation is null then\n                raise exception 'scheduling implementation not specified';\n            else\n                raise exception 'unrecognized scheduling implementation: \"%\"', _implementation;\n            end if;\n    end case;\nend\n$function$\n",
      "description": null,
      "arguments": "config jsonb",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpgsql"
    },
    {
      "oid": 18938,
      "name": "_vectorizer_add_embedding_column",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_add_embedding_column(source_schema name, source_table name, dimensions integer, embedding_column name)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _sql pg_catalog.text;\n    _column_exists pg_catalog.bool;\nbegin\n    -- Check if embedding column already exists\n    select exists(\n        select 1 \n        from pg_catalog.pg_attribute a\n        join pg_catalog.pg_class c on a.attrelid = c.oid\n        join pg_catalog.pg_namespace n on c.relnamespace = n.oid\n        where n.nspname = source_schema\n        and c.relname = source_table\n        and a.attname = embedding_column\n        and not a.attisdropped\n    ) into _column_exists;\n\n    if _column_exists then\n        raise notice 'embedding column %I already exists in %I.%I skipping creation', embedding_column, source_schema, source_table;\n        return;\n    else\n        -- Add embedding column to source table\n        select pg_catalog.format(\n            $sql$\n            alter table %I.%I \n            add column %I public.vector(%L) default null\n            $sql$,\n            source_schema, source_table, embedding_column, dimensions\n        ) into strict _sql;\n\n        execute _sql;\n\n        select pg_catalog.format(\n            $sql$alter table %I.%I alter column %I set storage main$sql$,\n            source_schema, source_table, embedding_column\n        ) into strict _sql;\n\n        execute _sql;\n    end if;\nend;\n$function$\n",
      "description": null,
      "arguments": "source_schema name, source_table name, dimensions integer, embedding_column name",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18943,
      "name": "_vectorizer_build_trigger_definition",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_build_trigger_definition(queue_schema name, queue_table name, target_schema name, target_table name, source_schema name, source_table name, source_pk jsonb)\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _pk_change_check pg_catalog.text;\n    _delete_statement pg_catalog.text;\n    _pk_columns pg_catalog.text;\n    _pk_values pg_catalog.text;\n    _func_def pg_catalog.text;\n    _relevant_columns_check pg_catalog.text;\n    _truncate_statement pg_catalog.text;\nbegin\n    -- Pre-calculate all the parts we need\n    select pg_catalog.string_agg(pg_catalog.format('%I', x.attname), ', ' order by x.attnum)\n    into strict _pk_columns\n    from pg_catalog.jsonb_to_recordset(source_pk) x(attnum int, attname name);\n\n    select pg_catalog.string_agg(pg_catalog.format('new.%I', x.attname), ', ' order by x.attnum)\n    into strict _pk_values\n    from pg_catalog.jsonb_to_recordset(source_pk) x(attnum int, attname name);\n\n    if target_schema is not null and target_table is not null then\n        -- Create delete statement for deleted rows\n        _delete_statement := format('delete from %I.%I where %s', target_schema, target_table,\n            (select string_agg(format('%I = old.%I', attname, attname), ' and ')\n            from pg_catalog.jsonb_to_recordset(source_pk) x(attnum int, attname name)));\n\n        -- Create the primary key change check expression\n        select string_agg(\n            format('old.%I IS DISTINCT FROM new.%I', attname, attname),\n            ' OR '\n        )\n        into strict _pk_change_check\n        from pg_catalog.jsonb_to_recordset(source_pk) x(attnum int, attname name);\n\n        _truncate_statement := format('truncate table %I.%I; truncate table %I.%I',\n                                target_schema, target_table, queue_schema, queue_table);\n    end if;\n\n    _relevant_columns_check := \n        pg_catalog.format('EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) ''destination'' operator(pg_catalog.->>) ''embedding_column''\n                FROM ai.vectorizer \n                WHERE source_table = %L AND source_schema = %L\n                AND config operator(pg_catalog.->) ''destination'' operator(pg_catalog.->>) ''implementation'' operator(pg_catalog.=) ''column''\n            )\n        )', source_table, source_schema);\n\n    if target_schema is not null and target_table is not null then\n        _func_def := $def$\n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    $DELETE_STATEMENT$;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if $PK_CHANGE_CHECK$ then\n                        $DELETE_STATEMENT$;\n                        insert into $QUEUE_SCHEMA$.$QUEUE_TABLE$ ($PK_COLUMNS$)\n                            values ($PK_VALUES$);\n                    -- check if a relevant column has changed and queue the update\n                    elsif $RELEVANT_COLUMNS_CHECK$ then\n                        insert into $QUEUE_SCHEMA$.$QUEUE_TABLE$ ($PK_COLUMNS$)\n                        values ($PK_VALUES$);\n                    end if;\n\n                    return new;\n                else\n                    insert into $QUEUE_SCHEMA$.$QUEUE_TABLE$ ($PK_COLUMNS$)\n                    values ($PK_VALUES$);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    $TRUNCATE_STATEMENT$;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        $def$;\n\n        -- Replace placeholders\n        _func_def := replace(_func_def, '$DELETE_STATEMENT$', _delete_statement);\n        _func_def := replace(_func_def, '$PK_CHANGE_CHECK$', _pk_change_check);\n        _func_def := replace(_func_def, '$QUEUE_SCHEMA$', quote_ident(queue_schema));\n        _func_def := replace(_func_def, '$QUEUE_TABLE$', quote_ident(queue_table));\n        _func_def := replace(_func_def, '$PK_COLUMNS$', _pk_columns);\n        _func_def := replace(_func_def, '$PK_VALUES$', _pk_values);\n        _func_def := replace(_func_def, '$TARGET_SCHEMA$', quote_ident(target_schema));\n        _func_def := replace(_func_def, '$TARGET_TABLE$', quote_ident(target_table));\n        _func_def := replace(_func_def, '$RELEVANT_COLUMNS_CHECK$', _relevant_columns_check);\n        _func_def := replace(_func_def, '$TRUNCATE_STATEMENT$', _truncate_statement);\n    \n    else\n        _func_def := $def$\n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'UPDATE') then\n                    if $RELEVANT_COLUMNS_CHECK$ then\n                        insert into $QUEUE_SCHEMA$.$QUEUE_TABLE$ ($PK_COLUMNS$)\n                        values ($PK_VALUES$);\n                    end if;\n                elseif (TG_OP = 'INSERT') then\n                    insert into $QUEUE_SCHEMA$.$QUEUE_TABLE$ ($PK_COLUMNS$)\n                    values ($PK_VALUES$);\n                end if;\n            end if;\n            return null;\n        end;\n        $def$;\n        _func_def := replace(_func_def, '$RELEVANT_COLUMNS_CHECK$', _relevant_columns_check);\n        _func_def := replace(_func_def, '$QUEUE_SCHEMA$', quote_ident(queue_schema));\n        _func_def := replace(_func_def, '$QUEUE_TABLE$', quote_ident(queue_table));\n        _func_def := replace(_func_def, '$PK_COLUMNS$', _pk_columns);\n        _func_def := replace(_func_def, '$PK_VALUES$', _pk_values);\n    end if;\n    return _func_def;\nend;\n$function$\n",
      "description": null,
      "arguments": "queue_schema name, queue_table name, target_schema name, target_table name, source_schema name, source_table name, source_pk jsonb",
      "return_type": "text",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpgsql"
    },
    {
      "oid": 18937,
      "name": "_vectorizer_create_destination_column",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_create_destination_column(source_schema name, source_table name, dimensions integer, destination jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    embedding_column pg_catalog.name;\nbegin\n    embedding_column = destination operator(pg_catalog.->>) 'embedding_column';\n    perform ai._vectorizer_add_embedding_column\n    ( source_schema\n    , source_table\n    , dimensions\n    , embedding_column\n    );\nend;\n$function$\n",
      "description": null,
      "arguments": "source_schema name, source_table name, dimensions integer, destination jsonb",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18936,
      "name": "_vectorizer_create_destination_table",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_create_destination_table(source_schema name, source_table name, source_pk jsonb, dimensions integer, destination jsonb, grant_to name[])\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    target_schema pg_catalog.name;\n    target_table pg_catalog.name;\n    view_schema pg_catalog.name;\n    view_name pg_catalog.name;\nbegin\n\n    target_schema = destination operator(pg_catalog.->>) 'target_schema';\n    target_table = destination operator(pg_catalog.->>) 'target_table';\n    view_schema = destination operator(pg_catalog.->>) 'view_schema';\n    view_name = destination operator(pg_catalog.->>) 'view_name';\n\n    -- create the target table\n    perform ai._vectorizer_create_target_table\n    ( source_pk\n    , target_schema\n    , target_table\n    , dimensions\n    , grant_to\n    );\n\n    perform ai._vectorizer_create_view\n    ( view_schema\n    , view_name\n    , source_schema\n    , source_table\n    , source_pk\n    , target_schema\n    , target_table\n    , grant_to\n    );\nend;\n$function$\n",
      "description": null,
      "arguments": "source_schema name, source_table name, source_pk jsonb, dimensions integer, destination jsonb, grant_to name[]",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18942,
      "name": "_vectorizer_create_queue_failed_table",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_create_queue_failed_table(queue_schema name, queue_failed_table name, source_pk jsonb, grant_to name[])\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _sql pg_catalog.text;\nbegin\n    -- create the table\n    select pg_catalog.format\n    ( $sql$\n      create table %I.%I\n      ( %s\n      , created_at pg_catalog.timestamptz not null default now()\n      , failure_step pg_catalog.text not null default ''\n      )\n      $sql$\n    , queue_schema, queue_failed_table\n    , (\n        select pg_catalog.string_agg\n        (\n          pg_catalog.format\n          ( '%I %s not null'\n          , x.attname\n          , x.typname\n          )\n          , E'\\n, '\n          order by x.attnum\n        )\n        from pg_catalog.jsonb_to_recordset(source_pk) x(attnum int, attname name, typname name)\n      )\n    ) into strict _sql\n    ;\n    execute _sql;\n\n    -- create the index\n    select pg_catalog.format\n    ( $sql$create index on %I.%I (%s)$sql$\n    , queue_schema, queue_failed_table\n    , (\n        select pg_catalog.string_agg(pg_catalog.format('%I', x.attname), ', ' order by x.pknum)\n        from pg_catalog.jsonb_to_recordset(source_pk) x(pknum int, attname name)\n      )\n    ) into strict _sql\n    ;\n    execute _sql;\n\n    if grant_to is not null then\n        -- grant usage on queue schema to grant_to roles\n        select pg_catalog.format\n        ( $sql$grant usage on schema %I to %s$sql$\n        , queue_schema\n        , (\n            select pg_catalog.string_agg(pg_catalog.quote_ident(x), ', ')\n            from pg_catalog.unnest(grant_to) x\n          )\n        ) into strict _sql;\n        execute _sql;\n\n        -- grant select, update, delete on queue table to grant_to roles\n        select pg_catalog.format\n        ( $sql$grant select, insert, update, delete on %I.%I to %s$sql$\n        , queue_schema\n        , queue_failed_table\n        , (\n            select pg_catalog.string_agg(pg_catalog.quote_ident(x), ', ')\n            from pg_catalog.unnest(grant_to) x\n          )\n        ) into strict _sql;\n        execute _sql;\n    end if;\nend;\n$function$\n",
      "description": null,
      "arguments": "queue_schema name, queue_failed_table name, source_pk jsonb, grant_to name[]",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18941,
      "name": "_vectorizer_create_queue_table",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_create_queue_table(queue_schema name, queue_table name, source_pk jsonb, grant_to name[])\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _sql pg_catalog.text;\nbegin\n    -- create the table\n    select pg_catalog.format\n    ( $sql$\n      create table %I.%I\n      ( %s\n      , queued_at pg_catalog.timestamptz not null default now()\n      , loading_retries pg_catalog.int4 not null default 0\n      , loading_retry_after pg_catalog.timestamptz\n      )\n      $sql$\n    , queue_schema, queue_table\n    , (\n        select pg_catalog.string_agg\n        (\n          pg_catalog.format\n          ( '%I %s not null'\n          , x.attname\n          , x.typname\n          )\n          , E'\\n, '\n          order by x.attnum\n        )\n        from pg_catalog.jsonb_to_recordset(source_pk) x(attnum int, attname name, typname name)\n      )\n    ) into strict _sql\n    ;\n    execute _sql;\n\n    -- create the index\n    select pg_catalog.format\n    ( $sql$create index on %I.%I (%s)$sql$\n    , queue_schema, queue_table\n    , (\n        select pg_catalog.string_agg(pg_catalog.format('%I', x.attname), ', ' order by x.pknum)\n        from pg_catalog.jsonb_to_recordset(source_pk) x(pknum int, attname name)\n      )\n    ) into strict _sql\n    ;\n    execute _sql;\n\n    if grant_to is not null then\n        -- grant usage on queue schema to grant_to roles\n        select pg_catalog.format\n        ( $sql$grant usage on schema %I to %s$sql$\n        , queue_schema\n        , (\n            select pg_catalog.string_agg(pg_catalog.quote_ident(x), ', ')\n            from pg_catalog.unnest(grant_to) x\n          )\n        ) into strict _sql;\n        execute _sql;\n\n        -- grant select, update, delete on queue table to grant_to roles\n        select pg_catalog.format\n        ( $sql$grant select, insert, update, delete on %I.%I to %s$sql$\n        , queue_schema\n        , queue_table\n        , (\n            select pg_catalog.string_agg(pg_catalog.quote_ident(x), ', ')\n            from pg_catalog.unnest(grant_to) x\n          )\n        ) into strict _sql;\n        execute _sql;\n    end if;\nend;\n$function$\n",
      "description": null,
      "arguments": "queue_schema name, queue_table name, source_pk jsonb, grant_to name[]",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18944,
      "name": "_vectorizer_create_source_trigger",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_create_source_trigger(trigger_name name, queue_schema name, queue_table name, source_schema name, source_table name, target_schema name, target_table name, source_pk jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _sql pg_catalog.text;\nbegin\n    \n    execute format\n    ( $sql$\n    create function %I.%I() returns trigger \n    as $trigger_def$ \n    %s\n    $trigger_def$ language plpgsql volatile parallel safe security definer \n    set search_path to pg_catalog, pg_temp\n    $sql$\n    , queue_schema\n    , trigger_name\n    , ai._vectorizer_build_trigger_definition(queue_schema,\n                                              queue_table,\n                                              target_schema,\n                                              target_table,\n                                              source_schema,\n                                              source_table,\n                                              source_pk)\n    );\n\n    -- Revoke public permissions\n    _sql := pg_catalog.format(\n        'revoke all on function %I.%I() from public',\n        queue_schema, trigger_name\n    );\n    execute _sql;\n\n    -- Create the row-level trigger\n    select pg_catalog.format(\n        $sql$\n        create trigger %I\n        after insert or update or delete\n        on %I.%I\n        for each row execute function %I.%I()\n        $sql$,\n        trigger_name,\n        source_schema, source_table,\n        queue_schema, trigger_name\n    ) into strict _sql\n    ;\n    execute _sql;\n    \n    -- Create the statement-level trigger for TRUNCATE\n    -- Note: Using the same trigger function but with a different event and level\n    select pg_catalog.format(\n        $sql$\n        create trigger %I_truncate\n        after truncate\n        on %I.%I\n        for each statement execute function %I.%I()\n        $sql$,\n        trigger_name,\n        source_schema, source_table,\n        queue_schema, trigger_name\n    ) into strict _sql\n    ;\n    execute _sql;\nend;\n$function$\n",
      "description": null,
      "arguments": "trigger_name name, queue_schema name, queue_table name, source_schema name, source_table name, target_schema name, target_table name, source_pk jsonb",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18939,
      "name": "_vectorizer_create_target_table",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_create_target_table(source_pk jsonb, target_schema name, target_table name, dimensions integer, grant_to name[])\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _pk_cols pg_catalog.text;\n    _sql pg_catalog.text;\nbegin\n    select pg_catalog.string_agg(pg_catalog.format('%I', x.attname), ', ' order by x.pknum)\n    into strict _pk_cols\n    from pg_catalog.jsonb_to_recordset(source_pk) x(pknum int, attname name)\n    ;\n\n    select pg_catalog.format\n    ( $sql$\n    create table %I.%I\n    ( embedding_uuid uuid not null primary key default pg_catalog.gen_random_uuid()\n    , %s\n    , chunk_seq int not null\n    , chunk text not null\n    , embedding public.vector(%L) not null\n    , unique (%s, chunk_seq)\n    )\n    $sql$\n    , target_schema, target_table\n    , (\n        select pg_catalog.string_agg\n        (\n            pg_catalog.format\n            ( '%I %s not null'\n            , x.attname\n            , x.typname\n            )\n            , E'\\n, '\n            order by x.attnum\n        )\n        from pg_catalog.jsonb_to_recordset(source_pk)\n            x(attnum int, attname name, typname name)\n      )\n    , dimensions\n    , _pk_cols\n    ) into strict _sql\n    ;\n    execute _sql;\n\n    select pg_catalog.format\n       ( $sql$alter table %I.%I alter column embedding set storage main$sql$\n       , target_schema\n       , target_table\n       ) into strict _sql\n    ;\n    execute _sql;\n\n    if grant_to is not null then\n        -- grant usage on target schema to grant_to roles\n        select pg_catalog.format\n        ( $sql$grant usage on schema %I to %s$sql$\n        , target_schema\n        , (\n            select pg_catalog.string_agg(pg_catalog.quote_ident(x), ', ')\n            from pg_catalog.unnest(grant_to) x\n          )\n        ) into strict _sql;\n        execute _sql;\n\n        -- grant select, insert, update on target table to grant_to roles\n        select pg_catalog.format\n        ( $sql$grant select, insert, update on %I.%I to %s$sql$\n        , target_schema\n        , target_table\n        , (\n            select pg_catalog.string_agg(pg_catalog.quote_ident(x), ', ')\n            from pg_catalog.unnest(grant_to) x\n          )\n        ) into strict _sql;\n        execute _sql;\n    end if;\nend;\n$function$\n",
      "description": null,
      "arguments": "source_pk jsonb, target_schema name, target_table name, dimensions integer, grant_to name[]",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18947,
      "name": "_vectorizer_create_vector_index",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_create_vector_index(target_schema name, target_table name, indexing jsonb, column_name name DEFAULT 'embedding'::name)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _key1 pg_catalog.int4 = 1982010642;\n    _key2 pg_catalog.int4;\n    _implementation pg_catalog.text;\n    _with_count pg_catalog.int8;\n    _with pg_catalog.text;\n    _ext_schema pg_catalog.name;\n    _sql pg_catalog.text;\nbegin\n\n    -- use the target table's oid as the second key for the advisory lock\n    select k.oid::pg_catalog.int4 into strict _key2\n    from pg_catalog.pg_class k\n    inner join pg_catalog.pg_namespace n on (k.relnamespace operator(pg_catalog.=) n.oid)\n    where k.relname operator(pg_catalog.=) target_table\n    and n.nspname operator(pg_catalog.=) target_schema\n    ;\n\n    -- try to grab a transaction-level advisory lock specific to the target table\n    -- if we get it, no one else is building the vector index. proceed\n    -- if we don't get it, someone else is already working on it. abort\n    if not pg_catalog.pg_try_advisory_xact_lock(_key1, _key2) then\n        raise warning 'another process is already building a vector index on %.%', target_schema, target_table;\n        return;\n    end if;\n\n    -- double-check that the index doesn't exist now that we're holding the advisory lock\n    -- nobody likes redundant indexes\n    if ai._vectorizer_vector_index_exists(target_schema, target_table, indexing, column_name) then\n        raise notice 'the vector index on %.% already exists', target_schema, target_table;\n        return;\n    end if;\n\n    _implementation = pg_catalog.jsonb_extract_path_text(indexing, 'implementation');\n    case _implementation\n        when 'diskann' then\n            select\n              pg_catalog.count(*)\n            , pg_catalog.string_agg\n              ( case w.key\n                  when 'storage_layout' then pg_catalog.format('%s=%L', w.key, w.value)\n                  when 'max_alpha' then pg_catalog.format('%s=%s', w.key, w.value::pg_catalog.float8)\n                  else pg_catalog.format('%s=%s', w.key, w.value::pg_catalog.int4)\n                end\n              , ', '\n              )\n            into strict\n              _with_count\n            , _with\n            from pg_catalog.jsonb_each_text(indexing) w\n            where w.key in\n            ( 'storage_layout'\n            , 'num_neighbors'\n            , 'search_list_size'\n            , 'max_alpha'\n            , 'num_dimensions'\n            , 'num_bits_per_dimension'\n            )\n            ;\n\n            select pg_catalog.format\n            ( $sql$create index on %I.%I using diskann (%I)%s$sql$\n            , target_schema, target_table\n            , column_name\n            , case when _with_count operator(pg_catalog.>) 0\n                then pg_catalog.format(' with (%s)', _with)\n                else ''\n              end\n            ) into strict _sql;\n            execute _sql;\n        when 'hnsw' then\n            select\n              pg_catalog.count(*)\n            , pg_catalog.string_agg(pg_catalog.format('%s=%s', w.key, w.value::pg_catalog.int4), ', ')\n            into strict\n              _with_count\n            , _with\n            from pg_catalog.jsonb_each_text(indexing) w\n            where w.key in ('m', 'ef_construction')\n            ;\n\n            select n.nspname into strict _ext_schema\n            from pg_catalog.pg_extension x\n            inner join pg_catalog.pg_namespace n on (x.extnamespace operator(pg_catalog.=) n.oid)\n            where x.extname operator(pg_catalog.=) 'vector'\n            ;\n\n            select pg_catalog.format\n            ( $sql$create index on %I.%I using hnsw (%I %I.%s)%s$sql$\n            , target_schema, target_table\n            , column_name\n            , _ext_schema\n            , indexing operator(pg_catalog.->>) 'opclass'\n            , case when _with_count operator(pg_catalog.>) 0\n                then pg_catalog.format(' with (%s)', _with)\n                else ''\n              end\n            ) into strict _sql;\n            execute _sql;\n        else\n            raise exception 'unrecognized index implementation: %s', _implementation;\n    end case;\nend\n$function$\n",
      "description": null,
      "arguments": "target_schema name, target_table name, indexing jsonb, column_name name DEFAULT 'embedding'::name",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18940,
      "name": "_vectorizer_create_view",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_create_view(view_schema name, view_name name, source_schema name, source_table name, source_pk jsonb, target_schema name, target_table name, grant_to name[])\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _sql pg_catalog.text;\nbegin\n    select pg_catalog.format\n    ( $sql$\n    create view %I.%I as\n    select\n      t.embedding_uuid\n    , t.chunk_seq\n    , t.chunk\n    , t.embedding\n    , %s\n    from %I.%I t\n    left outer join %I.%I s\n    on (%s)\n    $sql$\n    , view_schema, view_name\n    , (\n        -- take primary keys from the target table and other columns from source\n        -- this allows for join removal optimization\n        select pg_catalog.string_agg\n        (\n            pg_catalog.format\n            ( '%s.%I'\n            , case when x.attnum is not null then 't' else 's' end\n            , a.attname\n            )\n            , E'\\n    , '\n            order by a.attnum\n        )\n        from pg_catalog.pg_attribute a\n        left outer join pg_catalog.jsonb_to_recordset(source_pk) x(attnum int) on (a.attnum operator(pg_catalog.=) x.attnum)\n        where a.attrelid operator(pg_catalog.=) pg_catalog.format('%I.%I', source_schema, source_table)::pg_catalog.regclass::pg_catalog.oid\n        and a.attnum operator(pg_catalog.>) 0\n        and not a.attisdropped\n      )\n    , target_schema, target_table\n    , source_schema, source_table\n    , (\n        select pg_catalog.string_agg\n        (\n            pg_catalog.format\n            ( 't.%s = s.%s'\n            , x.attname\n            , x.attname\n            )\n            , ' and '\n            order by x.pknum\n        )\n        from pg_catalog.jsonb_to_recordset(source_pk)\n            x(pknum int, attname name)\n      )\n    ) into strict _sql;\n    execute _sql;\n\n    if grant_to is not null then\n        -- grant usage on view schema to grant_to roles\n        select pg_catalog.format\n        ( $sql$grant usage on schema %I to %s$sql$\n        , view_schema\n        , (\n            select pg_catalog.string_agg(pg_catalog.quote_ident(x), ', ')\n            from pg_catalog.unnest(grant_to) x\n          )\n        ) into strict _sql;\n        execute _sql;\n\n        -- grant select on view to grant_to roles\n        select pg_catalog.format\n        ( $sql$grant select on %I.%I to %s$sql$\n        , view_schema\n        , view_name\n        , (\n            select pg_catalog.string_agg(pg_catalog.quote_ident(x), ', ')\n            from pg_catalog.unnest(grant_to) x\n          )\n        ) into strict _sql;\n        execute _sql;\n    end if;\nend\n$function$\n",
      "description": null,
      "arguments": "view_schema name, view_name name, source_schema name, source_table name, source_pk jsonb, target_schema name, target_table name, grant_to name[]",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18934,
      "name": "_vectorizer_grant_to_source",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_grant_to_source(source_schema name, source_table name, grant_to name[])\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _sql pg_catalog.text;\nbegin\n    if grant_to is not null then\n        -- grant usage on source schema to grant_to roles\n        select pg_catalog.format\n        ( $sql$grant usage on schema %I to %s$sql$\n        , source_schema\n        , (\n            select pg_catalog.string_agg(pg_catalog.quote_ident(x), ', ')\n            from pg_catalog.unnest(grant_to) x\n          )\n        ) into strict _sql;\n        execute _sql;\n\n        -- grant select on source table to grant_to roles\n        select pg_catalog.format\n        ( $sql$grant select on %I.%I to %s$sql$\n        , source_schema\n        , source_table\n        , (\n            select pg_catalog.string_agg(pg_catalog.quote_ident(x), ', ')\n            from pg_catalog.unnest(grant_to) x\n          )\n        ) into strict _sql;\n        execute _sql;\n    end if;\nend;\n$function$\n",
      "description": null,
      "arguments": "source_schema name, source_table name, grant_to name[]",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18935,
      "name": "_vectorizer_grant_to_vectorizer",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_grant_to_vectorizer(grant_to name[])\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _sql pg_catalog.text;\nbegin\n    if grant_to is not null then\n        -- grant usage on schema ai to grant_to roles\n        select pg_catalog.format\n        ( $sql$grant usage on schema ai to %s$sql$\n        , (\n            select pg_catalog.string_agg(pg_catalog.quote_ident(x), ', ')\n            from pg_catalog.unnest(grant_to) x\n          )\n        ) into strict _sql;\n        execute _sql;\n\n        -- grant select on vectorizer table to grant_to roles\n        select pg_catalog.format\n        ( $sql$grant select on ai.vectorizer to %s$sql$\n        , (\n            select pg_catalog.string_agg(pg_catalog.quote_ident(x), ', ')\n            from pg_catalog.unnest(grant_to) x\n          )\n        ) into strict _sql;\n        execute _sql;\n    end if;\nend;\n$function$\n",
      "description": null,
      "arguments": "grant_to name[]",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18949,
      "name": "_vectorizer_job",
      "definition": "CREATE OR REPLACE PROCEDURE ai._vectorizer_job(IN job_id integer DEFAULT NULL::integer, IN config jsonb DEFAULT NULL::jsonb)\n LANGUAGE plpgsql\nAS $procedure$\ndeclare\n    _vectorizer_id pg_catalog.int4;\n    _vec ai.vectorizer%rowtype;\n    _sql pg_catalog.text;\n    _found pg_catalog.bool;\n    _count pg_catalog.int8;\n    _should_create_vector_index pg_catalog.bool;\nbegin\n    set local search_path = pg_catalog, pg_temp;\n    if config is null then\n        raise exception 'config is null';\n    end if;\n\n    -- get the vectorizer id from the config\n    select pg_catalog.jsonb_extract_path_text(config, 'vectorizer_id')::pg_catalog.int4\n    into strict _vectorizer_id\n    ;\n\n    -- get the vectorizer\n    select * into strict _vec\n    from ai.vectorizer v\n    where v.id operator(pg_catalog.=) _vectorizer_id\n    ;\n\n    commit;\n    set local search_path = pg_catalog, pg_temp;\n\n    _should_create_vector_index = ai._vectorizer_should_create_vector_index(_vec);\n\n    -- if the conditions are right, create the vectorizer index\n    if _should_create_vector_index and _vec.config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'table' then\n        commit;\n        set local search_path = pg_catalog, pg_temp;\n        perform ai._vectorizer_create_vector_index\n        (_vec.config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'target_schema'\n        , _vec.config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'target_table'\n        , pg_catalog.jsonb_extract_path(_vec.config, 'indexing')\n        );\n    elsif _should_create_vector_index and _vec.config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column' then\n        commit;\n        set local search_path = pg_catalog, pg_temp;\n        perform ai._vectorizer_create_vector_index\n        (_vec.source_schema\n        , _vec.source_table\n        , pg_catalog.jsonb_extract_path(_vec.config, 'indexing')\n        , _vec.config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n        );\n    end if;\n\n    commit;\n    set local search_path = pg_catalog, pg_temp;\n\n    -- if there is at least one item in the queue, we need to execute the vectorizer\n    select pg_catalog.format\n    ( $sql$\n    select true\n    from %I.%I\n    for update skip locked\n    limit 1\n    $sql$\n    , _vec.queue_schema, _vec.queue_table\n    ) into strict _sql\n    ;\n    execute _sql into _found;\n    commit;\n    set local search_path = pg_catalog, pg_temp;\n    if coalesce(_found, false) is true then\n        -- count total items in the queue\n        select pg_catalog.format\n        ( $sql$select pg_catalog.count(1) from (select 1 from %I.%I limit 501) $sql$\n        , _vec.queue_schema, _vec.queue_table\n        ) into strict _sql\n        ;\n        execute _sql into strict _count;\n        commit;\n        set local search_path = pg_catalog, pg_temp;\n        -- for every 50 items in the queue, execute a vectorizer max out at 10 vectorizers\n        _count = least(pg_catalog.ceil(_count::pg_catalog.float8 / 50.0::pg_catalog.float8), 10::pg_catalog.float8)::pg_catalog.int8;\n        raise debug 'job_id %: executing % vectorizers...', job_id, _count;\n        while _count > 0 loop\n            -- execute the vectorizer\n            perform ai.execute_vectorizer(_vectorizer_id);\n            _count = _count - 1;\n        end loop;\n    end if;\n    commit;\n    set local search_path = pg_catalog, pg_temp;\nend\n$procedure$\n",
      "description": null,
      "arguments": "IN job_id integer DEFAULT NULL::integer, IN config jsonb DEFAULT NULL::jsonb",
      "return_type": null,
      "kind": "p",
      "kind_label": "procedure",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18948,
      "name": "_vectorizer_schedule_job",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_schedule_job(vectorizer_id integer, scheduling jsonb)\n RETURNS bigint\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _implementation pg_catalog.text;\n    _sql pg_catalog.text;\n    _extension_schema pg_catalog.name;\n    _job_id pg_catalog.int8;\n    _ai_extension_exists pg_catalog.bool;\nbegin\n    select pg_catalog.jsonb_extract_path_text(scheduling, 'implementation')\n    into strict _implementation\n    ;\n    case\n        when _implementation operator(pg_catalog.=) 'timescaledb' then\n            select pg_catalog.count(*) > 0\n            into strict _ai_extension_exists\n            from pg_catalog.pg_extension x\n            where x.extname operator(pg_catalog.=) 'ai';\n            \n            if not _ai_extension_exists then\n                raise exception 'ai extension not found but it is needed for timescaledb scheduling.';\n            end if;\n            -- look up schema/name of the extension for scheduling. may be null\n            select n.nspname into _extension_schema\n            from pg_catalog.pg_extension x\n            inner join pg_catalog.pg_namespace n on (x.extnamespace operator(pg_catalog.=) n.oid)\n            where x.extname operator(pg_catalog.=) _implementation\n            ;\n            if _extension_schema is null then\n                raise exception 'timescaledb extension not found';\n            end if;\n        when _implementation operator(pg_catalog.=) 'none' then\n            return null;\n        else\n            raise exception 'scheduling implementation not recognized';\n    end case;\n\n    -- schedule the job using the implementation chosen\n    case _implementation\n        when 'timescaledb' then\n            -- schedule the work proc with timescaledb background jobs\n            select pg_catalog.format\n            ( $$select %I.add_job('ai._vectorizer_job'::pg_catalog.regproc, %s, config=>%L)$$\n            , _extension_schema\n            , ( -- gather up the arguments\n                select pg_catalog.string_agg\n                ( pg_catalog.format('%s=>%L', s.key, s.value)\n                , ', '\n                order by x.ord\n                )\n                from pg_catalog.jsonb_each_text(scheduling) s\n                inner join\n                pg_catalog.unnest(array['schedule_interval', 'initial_start', 'fixed_schedule', 'timezone']) with ordinality x(key, ord)\n                on (s.key = x.key)\n              )\n            , pg_catalog.jsonb_build_object('vectorizer_id', vectorizer_id)::pg_catalog.text\n            ) into strict _sql\n            ;\n            execute _sql into strict _job_id;\n    end case;\n    return _job_id;\nend\n$function$\n",
      "description": null,
      "arguments": "vectorizer_id integer, scheduling jsonb",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18946,
      "name": "_vectorizer_should_create_vector_index",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_should_create_vector_index(vectorizer ai.vectorizer)\n RETURNS boolean\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _indexing pg_catalog.jsonb;\n    _implementation pg_catalog.text;\n    _create_when_queue_empty pg_catalog.bool;\n    _sql pg_catalog.text;\n    _count pg_catalog.int8;\n    _min_rows pg_catalog.int8;\n    _schema_name pg_catalog.name;\n    _table_name pg_catalog.name;\n    _column_name pg_catalog.name;\nbegin\n    -- grab the indexing config\n    _indexing = pg_catalog.jsonb_extract_path(vectorizer.config, 'indexing');\n    if _indexing is null then\n        return false;\n    end if;\n\n    -- grab the indexing config's implementation\n    _implementation = pg_catalog.jsonb_extract_path_text(_indexing, 'implementation');\n    -- if implementation is missing or none, exit\n    if _implementation is null or _implementation = 'none' then\n        return false;\n    end if;\n\n    _schema_name = coalesce(vectorizer.config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'target_schema', vectorizer.source_schema);\n    _table_name = coalesce(vectorizer.config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'target_table', vectorizer.source_table);\n    _column_name = coalesce(vectorizer.config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column', 'embedding');\n    -- see if the index already exists. if so, exit\n    if ai._vectorizer_vector_index_exists(_schema_name, _table_name, _indexing, _column_name) then\n        return false;\n    end if;\n\n    -- if flag set, only attempt to create the vector index if the queue table is empty\n    _create_when_queue_empty = coalesce(pg_catalog.jsonb_extract_path(_indexing, 'create_when_queue_empty')::pg_catalog.bool, true);\n    if _create_when_queue_empty then\n        -- count the rows in the queue table\n        select pg_catalog.format\n        ( $sql$select pg_catalog.count(1) from %I.%I limit 1$sql$\n        , vectorizer.queue_schema\n        , vectorizer.queue_table\n        ) into strict _sql\n        ;\n        execute _sql into _count;\n        if _count operator(pg_catalog.>) 0 then\n            raise notice 'queue for %.% is not empty. skipping vector index creation', _schema_name, _table_name;\n            return false;\n        end if;\n    end if;\n\n    -- if min_rows has a value\n    _min_rows = coalesce(pg_catalog.jsonb_extract_path_text(_indexing, 'min_rows')::pg_catalog.int8, 0);\n    if _min_rows > 0 then\n        -- count the rows in the target table\n        select pg_catalog.format\n        ( $sql$select pg_catalog.count(*) from (select 1 from %I.%I limit %L) x$sql$\n        , _schema_name\n        , _table_name\n        , _min_rows\n        ) into strict _sql\n        ;\n        execute _sql into _count;\n    end if;\n\n    -- if we have met or exceeded min_rows, create the index\n    return coalesce(_count, 0) >= _min_rows;\nend\n$function$\n",
      "description": null,
      "arguments": "vectorizer ai.vectorizer",
      "return_type": "boolean",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18933,
      "name": "_vectorizer_source_pk",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_source_pk(source_table regclass)\n RETURNS jsonb\n LANGUAGE sql\n STABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select pg_catalog.jsonb_agg(x)\n    from\n    (\n        select e.attnum, e.pknum, a.attname, pg_catalog.format_type(y.oid, a.atttypmod) as typname\n        from pg_catalog.pg_constraint k\n        cross join lateral pg_catalog.unnest(k.conkey) with ordinality e(attnum, pknum)\n        inner join pg_catalog.pg_attribute a\n            on (k.conrelid operator(pg_catalog.=) a.attrelid\n                and e.attnum operator(pg_catalog.=) a.attnum)\n        inner join pg_catalog.pg_type y on (a.atttypid operator(pg_catalog.=) y.oid)\n        where k.conrelid operator(pg_catalog.=) source_table\n        and k.contype operator(pg_catalog.=) 'p'\n    ) x\n$function$\n",
      "description": null,
      "arguments": "source_table regclass",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "s",
      "volatility_label": "stable",
      "language": "sql"
    },
    {
      "oid": 19046,
      "name": "_vectorizer_src_trg_1",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_1()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.blog_contents_embeddings_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.blog_contents_embeddings_store where id = old.id;\n                        insert into ai._vectorizer_q_1 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'blog' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_1 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_1 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.blog_contents_embeddings_store; truncate table ai._vectorizer_q_1;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1974292,
      "name": "_vectorizer_src_trg_132",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_132()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_all_minilm_22m_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_all_minilm_22m_store where id = old.id;\n                        insert into ai._vectorizer_q_132 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_132 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_132 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_all_minilm_22m_store; truncate table ai._vectorizer_q_132;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1974323,
      "name": "_vectorizer_src_trg_133",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_133()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_all_minilm_33m_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_all_minilm_33m_store where id = old.id;\n                        insert into ai._vectorizer_q_133 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_133 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_133 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_all_minilm_33m_store; truncate table ai._vectorizer_q_133;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1974354,
      "name": "_vectorizer_src_trg_134",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_134()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_snowflake_arctic_embed_22m_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_snowflake_arctic_embed_22m_store where id = old.id;\n                        insert into ai._vectorizer_q_134 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_134 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_134 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_snowflake_arctic_embed_22m_store; truncate table ai._vectorizer_q_134;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1974385,
      "name": "_vectorizer_src_trg_135",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_135()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_snowflake_arctic_embed_110m_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_snowflake_arctic_embed_110m_store where id = old.id;\n                        insert into ai._vectorizer_q_135 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_135 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_135 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_snowflake_arctic_embed_110m_store; truncate table ai._vectorizer_q_135;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1974416,
      "name": "_vectorizer_src_trg_136",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_136()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_snowflake_arctic_embed_137m_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_snowflake_arctic_embed_137m_store where id = old.id;\n                        insert into ai._vectorizer_q_136 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_136 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_136 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_snowflake_arctic_embed_137m_store; truncate table ai._vectorizer_q_136;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1974447,
      "name": "_vectorizer_src_trg_137",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_137()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_snowflake_arctic_embed_335m_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_snowflake_arctic_embed_335m_store where id = old.id;\n                        insert into ai._vectorizer_q_137 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_137 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_137 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_snowflake_arctic_embed_335m_store; truncate table ai._vectorizer_q_137;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 19091,
      "name": "_vectorizer_src_trg_2",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_2()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.wiki_embedding_storage where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.wiki_embedding_storage where id = old.id;\n                        insert into ai._vectorizer_q_2 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'wiki' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_2 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_2 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.wiki_embedding_storage; truncate table ai._vectorizer_q_2;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 20813,
      "name": "_vectorizer_src_trg_48",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_48()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_nomic_embed_text_1_5_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_nomic_embed_text_1_5_store where id = old.id;\n                        insert into ai._vectorizer_q_48 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_48 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_48 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_nomic_embed_text_1_5_store; truncate table ai._vectorizer_q_48;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 20844,
      "name": "_vectorizer_src_trg_49",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_49()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_embeddinggemma_300m_qat_q4_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_embeddinggemma_300m_qat_q4_store where id = old.id;\n                        insert into ai._vectorizer_q_49 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_49 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_49 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_embeddinggemma_300m_qat_q4_store; truncate table ai._vectorizer_q_49;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 20875,
      "name": "_vectorizer_src_trg_50",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_50()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_embeddinggemma_300m_qat_q8_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_embeddinggemma_300m_qat_q8_store where id = old.id;\n                        insert into ai._vectorizer_q_50 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_50 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_50 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_embeddinggemma_300m_qat_q8_store; truncate table ai._vectorizer_q_50;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 20906,
      "name": "_vectorizer_src_trg_51",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_51()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_embeddinggemma_300m_bf16_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_embeddinggemma_300m_bf16_store where id = old.id;\n                        insert into ai._vectorizer_q_51 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_51 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_51 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_embeddinggemma_300m_bf16_store; truncate table ai._vectorizer_q_51;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 20937,
      "name": "_vectorizer_src_trg_52",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_52()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_granite_embedding_30m_fp16_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_granite_embedding_30m_fp16_store where id = old.id;\n                        insert into ai._vectorizer_q_52 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_52 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_52 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_granite_embedding_30m_fp16_store; truncate table ai._vectorizer_q_52;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 20968,
      "name": "_vectorizer_src_trg_53",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_53()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_granite_embedding_278m_fp16_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_granite_embedding_278m_fp16_store where id = old.id;\n                        insert into ai._vectorizer_q_53 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_53 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_53 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_granite_embedding_278m_fp16_store; truncate table ai._vectorizer_q_53;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 20999,
      "name": "_vectorizer_src_trg_54",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_54()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_mxbai_embed_large_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_mxbai_embed_large_store where id = old.id;\n                        insert into ai._vectorizer_q_54 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_54 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_54 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_mxbai_embed_large_store; truncate table ai._vectorizer_q_54;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 21030,
      "name": "_vectorizer_src_trg_55",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_55()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_qwen3_embedding_8b_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_qwen3_embedding_8b_store where id = old.id;\n                        insert into ai._vectorizer_q_55 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_55 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_55 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_qwen3_embedding_8b_store; truncate table ai._vectorizer_q_55;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 21061,
      "name": "_vectorizer_src_trg_56",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_56()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_qwen3_embedding_4b_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_qwen3_embedding_4b_store where id = old.id;\n                        insert into ai._vectorizer_q_56 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_56 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_56 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_qwen3_embedding_4b_store; truncate table ai._vectorizer_q_56;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1887371,
      "name": "_vectorizer_src_trg_58",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_58()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_snowflake_arctic_embed2_568m_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_snowflake_arctic_embed2_568m_store where id = old.id;\n                        insert into ai._vectorizer_q_58 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_58 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_58 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_snowflake_arctic_embed2_568m_store; truncate table ai._vectorizer_q_58;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1887402,
      "name": "_vectorizer_src_trg_59",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_59()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_bge_large_335m_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_bge_large_335m_store where id = old.id;\n                        insert into ai._vectorizer_q_59 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_59 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_59 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_bge_large_335m_store; truncate table ai._vectorizer_q_59;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1887433,
      "name": "_vectorizer_src_trg_60",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_60()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_qwen3_embedding_4b_q8_0_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_qwen3_embedding_4b_q8_0_store where id = old.id;\n                        insert into ai._vectorizer_q_60 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_60 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_60 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_qwen3_embedding_4b_q8_0_store; truncate table ai._vectorizer_q_60;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1887464,
      "name": "_vectorizer_src_trg_61",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_61()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_qwen3_embedding_0_6b_fp16_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_qwen3_embedding_0_6b_fp16_store where id = old.id;\n                        insert into ai._vectorizer_q_61 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_61 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_61 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_qwen3_embedding_0_6b_fp16_store; truncate table ai._vectorizer_q_61;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1887495,
      "name": "_vectorizer_src_trg_62",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_62()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_qwen3_embedding_0_6b_q8_0_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_qwen3_embedding_0_6b_q8_0_store where id = old.id;\n                        insert into ai._vectorizer_q_62 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_62 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_62 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_qwen3_embedding_0_6b_q8_0_store; truncate table ai._vectorizer_q_62;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1887526,
      "name": "_vectorizer_src_trg_63",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_63()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_bge_m3_567m_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_bge_m3_567m_store where id = old.id;\n                        insert into ai._vectorizer_q_63 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_63 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_63 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_bge_m3_567m_store; truncate table ai._vectorizer_q_63;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1887557,
      "name": "_vectorizer_src_trg_71",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_71()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.essays_qwen3_embedding_4b_q4_k_m_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.essays_qwen3_embedding_4b_q4_k_m_store where id = old.id;\n                        insert into ai._vectorizer_q_71 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_71 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_71 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.essays_qwen3_embedding_4b_q4_k_m_store; truncate table ai._vectorizer_q_71;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1965438,
      "name": "_vectorizer_src_trg_72",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_72()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_nomic_embed_text_1_5_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_nomic_embed_text_1_5_store where id = old.id;\n                        insert into ai._vectorizer_q_72 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_72 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_72 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_nomic_embed_text_1_5_store; truncate table ai._vectorizer_q_72;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1965469,
      "name": "_vectorizer_src_trg_73",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_73()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_snowflake_arctic_embed2_568m_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_snowflake_arctic_embed2_568m_store where id = old.id;\n                        insert into ai._vectorizer_q_73 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_73 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_73 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_snowflake_arctic_embed2_568m_store; truncate table ai._vectorizer_q_73;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1965500,
      "name": "_vectorizer_src_trg_74",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_74()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_bge_large_335m_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_bge_large_335m_store where id = old.id;\n                        insert into ai._vectorizer_q_74 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_74 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_74 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_bge_large_335m_store; truncate table ai._vectorizer_q_74;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1965531,
      "name": "_vectorizer_src_trg_75",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_75()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_qwen3_embedding_4b_q8_0_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_qwen3_embedding_4b_q8_0_store where id = old.id;\n                        insert into ai._vectorizer_q_75 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_75 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_75 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_qwen3_embedding_4b_q8_0_store; truncate table ai._vectorizer_q_75;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1965562,
      "name": "_vectorizer_src_trg_76",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_76()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_qwen3_embedding_0_6b_fp16_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_qwen3_embedding_0_6b_fp16_store where id = old.id;\n                        insert into ai._vectorizer_q_76 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_76 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_76 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_qwen3_embedding_0_6b_fp16_store; truncate table ai._vectorizer_q_76;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1965593,
      "name": "_vectorizer_src_trg_77",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_77()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_qwen3_embedding_0_6b_q8_0_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_qwen3_embedding_0_6b_q8_0_store where id = old.id;\n                        insert into ai._vectorizer_q_77 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_77 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_77 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_qwen3_embedding_0_6b_q8_0_store; truncate table ai._vectorizer_q_77;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1965624,
      "name": "_vectorizer_src_trg_78",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_78()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_bge_m3_567m_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_bge_m3_567m_store where id = old.id;\n                        insert into ai._vectorizer_q_78 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_78 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_78 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_bge_m3_567m_store; truncate table ai._vectorizer_q_78;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1965655,
      "name": "_vectorizer_src_trg_79",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_79()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_embeddinggemma_300m_qat_q4_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_embeddinggemma_300m_qat_q4_store where id = old.id;\n                        insert into ai._vectorizer_q_79 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_79 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_79 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_embeddinggemma_300m_qat_q4_store; truncate table ai._vectorizer_q_79;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1965686,
      "name": "_vectorizer_src_trg_80",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_80()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_embeddinggemma_300m_qat_q8_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_embeddinggemma_300m_qat_q8_store where id = old.id;\n                        insert into ai._vectorizer_q_80 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_80 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_80 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_embeddinggemma_300m_qat_q8_store; truncate table ai._vectorizer_q_80;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1965717,
      "name": "_vectorizer_src_trg_81",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_81()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_embeddinggemma_300m_bf16_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_embeddinggemma_300m_bf16_store where id = old.id;\n                        insert into ai._vectorizer_q_81 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_81 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_81 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_embeddinggemma_300m_bf16_store; truncate table ai._vectorizer_q_81;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1965748,
      "name": "_vectorizer_src_trg_82",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_82()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_granite_embedding_30m_fp16_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_granite_embedding_30m_fp16_store where id = old.id;\n                        insert into ai._vectorizer_q_82 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_82 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_82 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_granite_embedding_30m_fp16_store; truncate table ai._vectorizer_q_82;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1965779,
      "name": "_vectorizer_src_trg_83",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_83()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_granite_embedding_278m_fp16_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_granite_embedding_278m_fp16_store where id = old.id;\n                        insert into ai._vectorizer_q_83 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_83 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_83 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_granite_embedding_278m_fp16_store; truncate table ai._vectorizer_q_83;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1965810,
      "name": "_vectorizer_src_trg_84",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_84()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_mxbai_embed_large_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_mxbai_embed_large_store where id = old.id;\n                        insert into ai._vectorizer_q_84 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_84 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_84 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_mxbai_embed_large_store; truncate table ai._vectorizer_q_84;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1965841,
      "name": "_vectorizer_src_trg_85",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_85()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_qwen3_embedding_8b_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_qwen3_embedding_8b_store where id = old.id;\n                        insert into ai._vectorizer_q_85 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_85 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_85 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_qwen3_embedding_8b_store; truncate table ai._vectorizer_q_85;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 1965872,
      "name": "_vectorizer_src_trg_86",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_src_trg_86()\n RETURNS trigger\n LANGUAGE plpgsql\n PARALLEL SAFE SECURITY DEFINER\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$ \n    \n        begin\n            if (TG_LEVEL = 'ROW') then\n                if (TG_OP = 'DELETE') then\n                    delete from public.emb_essays_qwen3_embedding_4b_q4_k_m_store where id = old.id;\n                elsif (TG_OP = 'UPDATE') then\n                    -- Check if the primary key has changed and queue the update\n                    if old.id IS DISTINCT FROM new.id then\n                        delete from public.emb_essays_qwen3_embedding_4b_q4_k_m_store where id = old.id;\n                        insert into ai._vectorizer_q_86 (id)\n                            values (new.id);\n                    -- check if a relevant column has changed and queue the update\n                    elsif EXISTS (\n            SELECT 1 FROM pg_catalog.jsonb_each(to_jsonb(old)) AS o(key, value)\n            JOIN pg_catalog.jsonb_each(to_jsonb(new)) AS n(key, value) \n            ON o.key = n.key\n            WHERE o.value IS DISTINCT FROM n.value\n            AND o.key != ALL(\n                SELECT config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'embedding_column'\n                FROM ai.vectorizer \n                WHERE source_table = 'pg_essays' AND source_schema = 'public'\n                AND config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'column'\n            )\n        ) then\n                        insert into ai._vectorizer_q_86 (id)\n                        values (new.id);\n                    end if;\n\n                    return new;\n                else\n                    insert into ai._vectorizer_q_86 (id)\n                    values (new.id);\n                    return new;\n                end if;\n\n            elsif (TG_LEVEL = 'STATEMENT') then\n                if (TG_OP = 'TRUNCATE') then\n                    truncate table public.emb_essays_qwen3_embedding_4b_q4_k_m_store; truncate table ai._vectorizer_q_86;\n                end if;\n                return null;\n            end if;\n\n            return null;\n        end;\n        \n    $function$\n",
      "description": null,
      "arguments": "",
      "return_type": "trigger",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18945,
      "name": "_vectorizer_vector_index_exists",
      "definition": "CREATE OR REPLACE FUNCTION ai._vectorizer_vector_index_exists(target_schema name, target_table name, indexing jsonb, column_name name DEFAULT 'embedding'::name)\n RETURNS boolean\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _implementation pg_catalog.text;\n    _found pg_catalog.bool;\nbegin\n    _implementation = pg_catalog.jsonb_extract_path_text(indexing, 'implementation');\n    if _implementation not in ('diskann', 'hnsw') then\n        raise exception 'unrecognized index implementation: %s', _implementation;\n    end if;\n\n    -- look for an index on the target table where the indexed column is the \"embedding\" column\n    -- and the index is using the correct implementation\n    select pg_catalog.count(*) filter\n    ( where pg_catalog.pg_get_indexdef(i.indexrelid)\n      ilike pg_catalog.concat('% using ', _implementation, ' %')\n    ) > 0 into _found\n    from pg_catalog.pg_class k\n    inner join pg_catalog.pg_namespace n on (k.relnamespace operator(pg_catalog.=) n.oid)\n    inner join pg_index i on (k.oid operator(pg_catalog.=) i.indrelid)\n    inner join pg_catalog.pg_attribute a\n        on (k.oid operator(pg_catalog.=) a.attrelid\n        and a.attname operator(pg_catalog.=) column_name\n        and a.attnum operator(pg_catalog.=) i.indkey[0]\n        )\n    where n.nspname operator(pg_catalog.=) target_schema\n    and k.relname operator(pg_catalog.=) target_table\n    ;\n    return coalesce(_found, false);\nend\n$function$\n",
      "description": null,
      "arguments": "target_schema name, target_table name, indexing jsonb, column_name name DEFAULT 'embedding'::name",
      "return_type": "boolean",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18971,
      "name": "_worker_heartbeat",
      "definition": "CREATE OR REPLACE FUNCTION ai._worker_heartbeat(worker_id uuid, num_successes_since_last_heartbeat integer, num_errors_since_last_heartbeat integer, error_message text)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\nDECLARE\n    heartbeat_timestamp timestamptz = clock_timestamp();\nBEGIN\n    UPDATE ai.vectorizer_worker_process SET \n          last_heartbeat = heartbeat_timestamp \n        , heartbeat_count = heartbeat_count + 1 \n        , error_count = error_count + num_errors_since_last_heartbeat\n        , success_count = success_count + num_successes_since_last_heartbeat\n        , last_error_message = CASE WHEN error_message IS NOT NULL THEN error_message ELSE last_error_message END \n        , last_error_at = CASE WHEN error_message IS NOT NULL THEN heartbeat_timestamp ELSE last_error_at END \n    WHERE id = worker_id;\nEND;\n$function$\n",
      "description": null,
      "arguments": "worker_id uuid, num_successes_since_last_heartbeat integer, num_errors_since_last_heartbeat integer, error_message text",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18972,
      "name": "_worker_progress",
      "definition": "CREATE OR REPLACE FUNCTION ai._worker_progress(worker_id uuid, worker_vectorizer_id integer, num_successes integer, error_message text)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\nDECLARE\n    progress_timestamp timestamptz = clock_timestamp();\nBEGIN\n    IF NOT EXISTS (SELECT 1 FROM ai.vectorizer_worker_progress WHERE vectorizer_id = worker_vectorizer_id) THEN\n        --make sure a row exists for this vectorizer\n        INSERT INTO ai.vectorizer_worker_progress (vectorizer_id) VALUES (worker_vectorizer_id) ON CONFLICT DO NOTHING;\n    END IF;\n\n    UPDATE ai.vectorizer_worker_progress SET \n        last_success_at = CASE WHEN error_message IS NULL THEN progress_timestamp ELSE last_success_at END\n      , last_success_process_id = CASE WHEN error_message IS NULL THEN worker_id ELSE last_success_process_id END\n      , last_error_at = CASE WHEN error_message IS NULL THEN last_error_at ELSE progress_timestamp END\n      , last_error_message = CASE WHEN error_message IS NULL THEN last_error_message ELSE error_message END\n      , last_error_process_id = CASE WHEN error_message IS NULL THEN last_error_process_id ELSE worker_id END\n      , success_count = success_count + num_successes\n      , error_count = error_count + CASE WHEN error_message IS NULL THEN 0 ELSE 1 END\n    WHERE vectorizer_id = worker_vectorizer_id;\nEND;\n$function$\n",
      "description": null,
      "arguments": "worker_id uuid, worker_vectorizer_id integer, num_successes integer, error_message text",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18970,
      "name": "_worker_start",
      "definition": "CREATE OR REPLACE FUNCTION ai._worker_start(version text, expected_heartbeat_interval interval)\n RETURNS uuid\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\nDECLARE\n    worker_id uuid;\nBEGIN\n    --can add version check here\n    INSERT INTO ai.vectorizer_worker_process (version, expected_heartbeat_interval) VALUES (version, expected_heartbeat_interval) RETURNING id INTO worker_id;\n    RETURN worker_id;\nEND;\n$function$\n",
      "description": null,
      "arguments": "version text, expected_heartbeat_interval interval",
      "return_type": "uuid",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 19149,
      "name": "anthropic_generate",
      "definition": "CREATE OR REPLACE FUNCTION ai.anthropic_generate(model text, messages jsonb, max_tokens integer DEFAULT 1024, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, base_url text DEFAULT NULL::text, timeout double precision DEFAULT NULL::double precision, max_retries integer DEFAULT NULL::integer, system_prompt text DEFAULT NULL::text, user_id text DEFAULT NULL::text, stop_sequences text[] DEFAULT NULL::text[], temperature double precision DEFAULT NULL::double precision, tool_choice jsonb DEFAULT NULL::jsonb, tools jsonb DEFAULT NULL::jsonb, top_k integer DEFAULT NULL::integer, top_p double precision DEFAULT NULL::double precision, \"verbose\" boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE plpython3u\n PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.anthropic\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.anthropic.DEFAULT_KEY_NAME, SD)\n    client = ai.anthropic.make_client(api_key=api_key_resolved, base_url=base_url, timeout=timeout, max_retries=max_retries)\n\n    import json\n    messages_1 = json.loads(messages)\n\n    args = {}\n    if system_prompt is not None:\n        args[\"system\"] = system_prompt\n    if user_id is not None:\n        args[\"metadata\"] = {\"user_id\", user_id}\n    if stop_sequences is not None:\n        args[\"stop_sequences\"] = stop_sequences\n    if temperature is not None:\n        args[\"temperature\"] = temperature\n    if tool_choice is not None:\n        args[\"tool_choice\"] = json.loads(tool_choice)\n    if tools is not None:\n        args[\"tools\"] = json.loads(tools)\n    if top_k is not None:\n        args[\"top_k\"] = top_k\n    if top_p is not None:\n        args[\"top_p\"] = top_p\n\n    with ai.utils.VerboseRequestTrace(plpy, \"anthropic.generate()\", verbose):\n        message = client.messages.create(model=model, messages=messages_1, max_tokens=max_tokens, **args)\n    \n    return message.to_json()\n$function$\n",
      "description": null,
      "arguments": "model text, messages jsonb, max_tokens integer DEFAULT 1024, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, base_url text DEFAULT NULL::text, timeout double precision DEFAULT NULL::double precision, max_retries integer DEFAULT NULL::integer, system_prompt text DEFAULT NULL::text, user_id text DEFAULT NULL::text, stop_sequences text[] DEFAULT NULL::text[], temperature double precision DEFAULT NULL::double precision, tool_choice jsonb DEFAULT NULL::jsonb, tools jsonb DEFAULT NULL::jsonb, top_k integer DEFAULT NULL::integer, top_p double precision DEFAULT NULL::double precision, \"verbose\" boolean DEFAULT false",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 19148,
      "name": "anthropic_list_models",
      "definition": "CREATE OR REPLACE FUNCTION ai.anthropic_list_models(api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, base_url text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false)\n RETURNS TABLE(id text, name text, created timestamp with time zone)\n LANGUAGE plpython3u\n PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.anthropic\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.anthropic.DEFAULT_KEY_NAME, SD)\n    \n    with ai.utils.VerboseRequestTrace(plpy, \"anthropic.list_models()\", verbose):\n        result = ai.anthropic.list_models(api_key_resolved, base_url)\n    \n    for tup in result:\n        yield tup\n$function$\n",
      "description": null,
      "arguments": "api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, base_url text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false",
      "return_type": "TABLE(id text, name text, created timestamp with time zone)",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 19175,
      "name": "chunk_text",
      "definition": "CREATE OR REPLACE FUNCTION ai.chunk_text(input text, chunk_size integer DEFAULT NULL::integer, chunk_overlap integer DEFAULT NULL::integer, separator text DEFAULT NULL::text, is_separator_regex boolean DEFAULT false)\n RETURNS TABLE(seq bigint, chunk text)\n LANGUAGE plpython3u\n PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    from langchain_text_splitters import CharacterTextSplitter\n    \n    args = {}\n    if separator is not None:\n        args[\"separator\"] = separator\n    if chunk_size is not None:\n        args[\"chunk_size\"] = chunk_size\n    if chunk_overlap is not None:\n        args[\"chunk_overlap\"] = chunk_overlap\n    if is_separator_regex is not None:\n        args[\"is_separator_regex\"] = is_separator_regex\n    \n    chunker = CharacterTextSplitter(**args)\n    for ix, chunk in enumerate(chunker.split_text(input)):\n        yield ix, chunk\n$function$\n",
      "description": null,
      "arguments": "input text, chunk_size integer DEFAULT NULL::integer, chunk_overlap integer DEFAULT NULL::integer, separator text DEFAULT NULL::text, is_separator_regex boolean DEFAULT false",
      "return_type": "TABLE(seq bigint, chunk text)",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 19176,
      "name": "chunk_text_recursively",
      "definition": "CREATE OR REPLACE FUNCTION ai.chunk_text_recursively(input text, chunk_size integer DEFAULT NULL::integer, chunk_overlap integer DEFAULT NULL::integer, separators text[] DEFAULT NULL::text[], is_separator_regex boolean DEFAULT false)\n RETURNS TABLE(seq bigint, chunk text)\n LANGUAGE plpython3u\n PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    from langchain_text_splitters import RecursiveCharacterTextSplitter\n    \n    args = {}\n    if separators is not None:\n        args[\"separators\"] = separators\n    if chunk_size is not None:\n        args[\"chunk_size\"] = chunk_size\n    if chunk_overlap is not None:\n        args[\"chunk_overlap\"] = chunk_overlap\n    if is_separator_regex is not None:\n        args[\"is_separator_regex\"] = is_separator_regex\n    \n    chunker = RecursiveCharacterTextSplitter(**args)\n    for ix, chunk in enumerate(chunker.split_text(input)):\n        yield ix, chunk\n$function$\n",
      "description": null,
      "arguments": "input text, chunk_size integer DEFAULT NULL::integer, chunk_overlap integer DEFAULT NULL::integer, separators text[] DEFAULT NULL::text[], is_separator_regex boolean DEFAULT false",
      "return_type": "TABLE(seq bigint, chunk text)",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 18891,
      "name": "chunking_character_text_splitter",
      "definition": "CREATE OR REPLACE FUNCTION ai.chunking_character_text_splitter(chunk_size integer DEFAULT 800, chunk_overlap integer DEFAULT 400, separator text DEFAULT '\n\n'::text, is_separator_regex boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_strip_nulls(json_build_object\n    ( 'implementation', 'character_text_splitter'\n    , 'config_type', 'chunking'\n    , 'chunk_size', chunk_size\n    , 'chunk_overlap', chunk_overlap\n    , 'separator', separator\n    , 'is_separator_regex', is_separator_regex\n    ))\n$function$\n",
      "description": null,
      "arguments": "chunk_size integer DEFAULT 800, chunk_overlap integer DEFAULT 400, separator text DEFAULT '\n\n'::text, is_separator_regex boolean DEFAULT false",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18893,
      "name": "chunking_none",
      "definition": "CREATE OR REPLACE FUNCTION ai.chunking_none()\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_build_object\n    ( 'implementation', 'none'\n    , 'config_type', 'chunking'\n    )\n$function$\n",
      "description": null,
      "arguments": "",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18892,
      "name": "chunking_recursive_character_text_splitter",
      "definition": "CREATE OR REPLACE FUNCTION ai.chunking_recursive_character_text_splitter(chunk_size integer DEFAULT 800, chunk_overlap integer DEFAULT 400, separators text[] DEFAULT ARRAY['\n\n'::text, '\n'::text, '.'::text, '?'::text, '!'::text, ' '::text, ''::text], is_separator_regex boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_strip_nulls(json_build_object\n    ( 'implementation', 'recursive_character_text_splitter'\n    , 'config_type', 'chunking'\n    , 'chunk_size', chunk_size\n    , 'chunk_overlap', chunk_overlap\n    , 'separators', separators\n    , 'is_separator_regex', is_separator_regex\n    ))\n$function$\n",
      "description": null,
      "arguments": "chunk_size integer DEFAULT 800, chunk_overlap integer DEFAULT 400, separators text[] DEFAULT ARRAY['\n\n'::text, '\n'::text, '.'::text, '?'::text, '!'::text, ' '::text, ''::text], is_separator_regex boolean DEFAULT false",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 19159,
      "name": "cohere_chat_complete",
      "definition": "CREATE OR REPLACE FUNCTION ai.cohere_chat_complete(model text, messages jsonb, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, tools jsonb DEFAULT NULL::jsonb, documents jsonb DEFAULT NULL::jsonb, citation_options jsonb DEFAULT NULL::jsonb, response_format jsonb DEFAULT NULL::jsonb, safety_mode text DEFAULT NULL::text, max_tokens integer DEFAULT NULL::integer, stop_sequences text[] DEFAULT NULL::text[], temperature double precision DEFAULT NULL::double precision, seed integer DEFAULT NULL::integer, frequency_penalty double precision DEFAULT NULL::double precision, presence_penalty double precision DEFAULT NULL::double precision, k integer DEFAULT NULL::integer, p double precision DEFAULT NULL::double precision, logprobs boolean DEFAULT NULL::boolean, tool_choice text DEFAULT NULL::text, strict_tools boolean DEFAULT NULL::boolean, \"verbose\" boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE plpython3u\n PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.cohere\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.cohere.DEFAULT_KEY_NAME, SD)\n    client = ai.cohere.make_client(api_key_resolved)\n\n    import json\n    args = {}\n\n    if tools is not None:\n        args[\"tools\"] = json.loads(tools)\n    if documents is not None:\n        args[\"documents\"] = json.loads(documents)\n    if citation_options is not None:\n        args[\"citation_options\"] = json.loads(citation_options)\n    if response_format is not None:\n        args[\"response_format\"] = json.loads(response_format)\n    if safety_mode is not None:\n        args[\"safety_mode\"] = safety_mode\n    if max_tokens is not None:\n        args[\"max_tokens\"] = max_tokens\n    if stop_sequences is not None:\n        args[\"stop_sequences\"] = stop_sequences\n    if temperature is not None:\n        args[\"temperature\"] = temperature\n    if seed is not None:\n        args[\"seed\"] = seed\n    if frequency_penalty is not None:\n        args[\"frequency_penalty\"] = frequency_penalty\n    if presence_penalty is not None:\n        args[\"presence_penalty\"] = presence_penalty\n    if k is not None:\n        args[\"k\"] = k\n    if p is not None:\n        args[\"p\"] = p\n    if logprobs is not None:\n        args[\"logprobs\"] = logprobs\n    if tool_choice is not None:\n        args[\"tool_choice\"] = tool_choice\n    if strict_tools is not None:\n        args[\"strict_tools\"] = strict_tools\n\n    with ai.utils.VerboseRequestTrace(plpy, \"cohere.chat_complete()\", verbose):\n        response = client.chat(model=model, messages=json.loads(messages), **args)\n    return response.json()\n$function$\n",
      "description": null,
      "arguments": "model text, messages jsonb, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, tools jsonb DEFAULT NULL::jsonb, documents jsonb DEFAULT NULL::jsonb, citation_options jsonb DEFAULT NULL::jsonb, response_format jsonb DEFAULT NULL::jsonb, safety_mode text DEFAULT NULL::text, max_tokens integer DEFAULT NULL::integer, stop_sequences text[] DEFAULT NULL::text[], temperature double precision DEFAULT NULL::double precision, seed integer DEFAULT NULL::integer, frequency_penalty double precision DEFAULT NULL::double precision, presence_penalty double precision DEFAULT NULL::double precision, k integer DEFAULT NULL::integer, p double precision DEFAULT NULL::double precision, logprobs boolean DEFAULT NULL::boolean, tool_choice text DEFAULT NULL::text, strict_tools boolean DEFAULT NULL::boolean, \"verbose\" boolean DEFAULT false",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 19155,
      "name": "cohere_classify",
      "definition": "CREATE OR REPLACE FUNCTION ai.cohere_classify(model text, inputs text[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, examples jsonb DEFAULT NULL::jsonb, truncate_long_inputs text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.cohere\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.cohere.DEFAULT_KEY_NAME, SD)\n    client = ai.cohere.make_client(api_key_resolved)\n\n    import json\n    args = {}\n    if examples is not None:\n        args[\"examples\"] = json.loads(examples)\n    if truncate_long_inputs is not None:\n        args[\"truncate\"] = truncate_long_inputs\n\n    with ai.utils.VerboseRequestTrace(plpy, \"cohere.classify()\", verbose):\n        response = client.classify(inputs=inputs, model=model, **args)\n    return response.json()\n$function$\n",
      "description": null,
      "arguments": "model text, inputs text[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, examples jsonb DEFAULT NULL::jsonb, truncate_long_inputs text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19156,
      "name": "cohere_classify_simple",
      "definition": "CREATE OR REPLACE FUNCTION ai.cohere_classify_simple(model text, inputs text[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, examples jsonb DEFAULT NULL::jsonb, truncate_long_inputs text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false)\n RETURNS TABLE(input text, prediction text, confidence double precision)\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.cohere\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.cohere.DEFAULT_KEY_NAME, SD)\n    client = ai.cohere.make_client(api_key_resolved)\n\n    import json\n    args = {}\n    if examples is not None:\n        args[\"examples\"] = json.loads(examples)\n    if truncate_long_inputs is not None:\n        args[\"truncate\"] = truncate_long_inputs\n    \n    with ai.utils.VerboseRequestTrace(plpy, \"cohere.classify()\", verbose):\n        response = client.classify(inputs=inputs, model=model, **args)\n    for x in response.classifications:\n        yield x.input, x.prediction, x.confidence\n$function$\n",
      "description": null,
      "arguments": "model text, inputs text[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, examples jsonb DEFAULT NULL::jsonb, truncate_long_inputs text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false",
      "return_type": "TABLE(input text, prediction text, confidence double precision)",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19153,
      "name": "cohere_detokenize",
      "definition": "CREATE OR REPLACE FUNCTION ai.cohere_detokenize(model text, tokens integer[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false)\n RETURNS text\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.cohere\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.cohere.DEFAULT_KEY_NAME, SD)\n    client = ai.cohere.make_client(api_key_resolved)\n\n    with ai.utils.VerboseRequestTrace(plpy, \"cohere.detokenize()\", verbose):\n        response = client.detokenize(tokens=tokens, model=model)\n    return response.text\n$function$\n",
      "description": null,
      "arguments": "model text, tokens integer[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false",
      "return_type": "text",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19154,
      "name": "cohere_embed",
      "definition": "CREATE OR REPLACE FUNCTION ai.cohere_embed(model text, input_text text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, input_type text DEFAULT NULL::text, truncate_long_inputs text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false)\n RETURNS vector\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.cohere\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.cohere.DEFAULT_KEY_NAME, SD)\n    client = ai.cohere.make_client(api_key_resolved)\n\n    args={}\n    if input_type is not None:\n        args[\"input_type\"] = input_type\n    if truncate_long_inputs is not None:\n        args[\"truncate\"] = truncate_long_inputs\n    with ai.utils.VerboseRequestTrace(plpy, \"cohere.embed()\", verbose):\n        response = client.embed(texts=[input_text], model=model, embedding_types=[\"float\"], **args)\n    return response.embeddings.float[0]\n$function$\n",
      "description": null,
      "arguments": "model text, input_text text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, input_type text DEFAULT NULL::text, truncate_long_inputs text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false",
      "return_type": "vector",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19151,
      "name": "cohere_list_models",
      "definition": "CREATE OR REPLACE FUNCTION ai.cohere_list_models(api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, endpoint text DEFAULT NULL::text, default_only boolean DEFAULT NULL::boolean, \"verbose\" boolean DEFAULT false)\n RETURNS TABLE(name text, endpoints text[], finetuned boolean, context_length integer, tokenizer_url text, default_endpoints text[])\n LANGUAGE plpython3u\n PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.cohere\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.cohere.DEFAULT_KEY_NAME, SD)\n    client = ai.cohere.make_client(api_key_resolved)\n\n    args = {}\n    if endpoint is not None:\n        args[\"endpoint\"] = endpoint\n    if default_only is not None:\n        args[\"default_only\"] = default_only\n    page_token = None\n    while True:\n        with ai.utils.VerboseRequestTrace(plpy, \"cohere.list_models()\", verbose):\n            resp = client.models.list(page_size=1000, page_token=page_token, **args)\n        for model in resp.models:\n            yield (model.name, model.endpoints, model.finetuned, model.context_length, model.tokenizer_url, model.default_endpoints)\n        page_token = resp.next_page_token\n        if page_token is None:\n            break\n$function$\n",
      "description": null,
      "arguments": "api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, endpoint text DEFAULT NULL::text, default_only boolean DEFAULT NULL::boolean, \"verbose\" boolean DEFAULT false",
      "return_type": "TABLE(name text, endpoints text[], finetuned boolean, context_length integer, tokenizer_url text, default_endpoints text[])",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 19157,
      "name": "cohere_rerank",
      "definition": "CREATE OR REPLACE FUNCTION ai.cohere_rerank(model text, query text, documents text[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, top_n integer DEFAULT NULL::integer, max_tokens_per_doc integer DEFAULT NULL::integer, \"verbose\" boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.cohere\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.cohere.DEFAULT_KEY_NAME, SD)\n    client = ai.cohere.make_client(api_key_resolved)\n\n    args = {}\n    if top_n is not None:\n        args[\"top_n\"] = top_n\n    if max_tokens_per_doc is not None:\n        args[\"max_tokens_per_doc\"] = max_tokens_per_doc\n    with ai.utils.VerboseRequestTrace(plpy, \"cohere.rerank()\", verbose):\n        response = client.rerank(model=model, query=query, documents=documents, **args)\n    return response.json()\n$function$\n",
      "description": null,
      "arguments": "model text, query text, documents text[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, top_n integer DEFAULT NULL::integer, max_tokens_per_doc integer DEFAULT NULL::integer, \"verbose\" boolean DEFAULT false",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19158,
      "name": "cohere_rerank_simple",
      "definition": "CREATE OR REPLACE FUNCTION ai.cohere_rerank_simple(model text, query text, documents text[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, top_n integer DEFAULT NULL::integer, max_tokens_per_doc integer DEFAULT NULL::integer, \"verbose\" boolean DEFAULT false)\n RETURNS TABLE(index integer, document text, relevance_score double precision)\n LANGUAGE sql\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\nselect\n  x.\"index\"\n, d.document\n, x.relevance_score\nfrom pg_catalog.jsonb_to_recordset\n(\n    ai.cohere_rerank\n    ( model\n    , query\n    , documents\n    , api_key=>api_key\n    , api_key_name=>api_key_name\n    , top_n=>top_n\n    , max_tokens_per_doc=>max_tokens_per_doc\n    , verbose=>\"verbose\"\n    ) operator(pg_catalog.->) 'results'\n) x(\"index\" int, relevance_score float8)\ninner join unnest(documents) with ordinality d (document, ord)\non (x.\"index\" = (d.ord - 1))\n$function$\n",
      "description": null,
      "arguments": "model text, query text, documents text[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, top_n integer DEFAULT NULL::integer, max_tokens_per_doc integer DEFAULT NULL::integer, \"verbose\" boolean DEFAULT false",
      "return_type": "TABLE(index integer, document text, relevance_score double precision)",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 19152,
      "name": "cohere_tokenize",
      "definition": "CREATE OR REPLACE FUNCTION ai.cohere_tokenize(model text, text_input text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false)\n RETURNS integer[]\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.cohere\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.cohere.DEFAULT_KEY_NAME, SD)\n    client = ai.cohere.make_client(api_key_resolved)\n\n    with ai.utils.VerboseRequestTrace(plpy, \"cohere.tokenize()\", verbose):\n        response = client.tokenize(text=text_input, model=model)\n    return response.tokens\n$function$\n",
      "description": null,
      "arguments": "model text, text_input text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false",
      "return_type": "integer[]",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 18977,
      "name": "create_semantic_catalog",
      "definition": "CREATE OR REPLACE FUNCTION ai.create_semantic_catalog(catalog_name name DEFAULT 'default'::name, embedding_name name DEFAULT NULL::name, embedding_config jsonb DEFAULT ai.embedding_sentence_transformers())\n RETURNS integer\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _catalog_name name = create_semantic_catalog.catalog_name;\n    _embedding_name name = create_semantic_catalog.embedding_name;\n    _embedding_config jsonb = create_semantic_catalog.embedding_config;\n    _catalog_id int4;\n    _sql text;\nbegin\n    select nextval('ai.semantic_catalog_id_seq')\n    into strict _catalog_id\n    ;\n\n    insert into ai.semantic_catalog\n    ( id\n    , catalog_name\n    , obj_table\n    , sql_table\n    , fact_table\n    )\n    values \n    ( _catalog_id\n    , catalog_name\n    , array['ai', format('semantic_catalog_obj_%s', _catalog_id)]\n    , array['ai', format('semantic_catalog_sql_%s', _catalog_id)]\n    , array['ai', format('semantic_catalog_fact_%s', _catalog_id)]\n    )\n    ;\n    \n    -- create the table for database objects\n    _sql = format\n    ( $sql$\n        create table ai.semantic_catalog_obj_%s\n        ( id int8 not null primary key generated by default as identity\n        , classid oid not null\n        , objid oid not null\n        , objsubid int4 not null\n        , objtype text not null\n        , objnames text[] not null\n        , objargs text[] not null\n        , description text\n        , usage int8 not null default 0\n        , unique (classid, objid, objsubid) deferrable initially immediate\n        , unique (objtype, objnames, objargs) deferrable initially immediate\n        )\n      $sql$\n    , _catalog_id\n    );\n    raise debug '%', _sql;\n    execute _sql;\n    \n    -- create the table for example sql\n    _sql = format\n    ( $sql$\n        create table ai.semantic_catalog_sql_%s\n        ( id int8 not null primary key generated by default as identity\n        , sql text not null\n        , description text not null\n        , usage int8 not null default 0\n        )\n      $sql$\n    , _catalog_id\n    );\n    raise debug '%', _sql;\n    execute _sql;\n    \n    -- create the table for facts\n    _sql = format\n    ( $sql$\n        create table ai.semantic_catalog_fact_%s\n        ( id int8 not null primary key generated by default as identity\n        , description text not null\n        , usage int8 not null default 0\n        )\n      $sql$\n    , _catalog_id\n    );\n    raise debug '%', _sql;\n    execute _sql;\n    \n    perform ai.sc_add_embedding\n    ( embedding_name=>_embedding_name\n    , config=>_embedding_config\n    , catalog_name=>_catalog_name\n    );\n    \n    return _catalog_id;\nend;\n$function$\n",
      "description": null,
      "arguments": "catalog_name name DEFAULT 'default'::name, embedding_name name DEFAULT NULL::name, embedding_config jsonb DEFAULT ai.embedding_sentence_transformers()",
      "return_type": "integer",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18951,
      "name": "create_vectorizer",
      "definition": "CREATE OR REPLACE FUNCTION ai.create_vectorizer(source regclass, name text DEFAULT NULL::text, destination jsonb DEFAULT ai.destination_table(), loading jsonb DEFAULT NULL::jsonb, parsing jsonb DEFAULT ai.parsing_auto(), embedding jsonb DEFAULT NULL::jsonb, chunking jsonb DEFAULT ai.chunking_recursive_character_text_splitter(), indexing jsonb DEFAULT ai.indexing_default(), formatting jsonb DEFAULT ai.formatting_python_template(), scheduling jsonb DEFAULT ai.scheduling_default(), processing jsonb DEFAULT ai.processing_default(), queue_schema name DEFAULT NULL::name, queue_table name DEFAULT NULL::name, grant_to name[] DEFAULT ai.grant_to(), enqueue_existing boolean DEFAULT true, if_not_exists boolean DEFAULT false)\n RETURNS integer\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _missing_roles pg_catalog.name[];\n    _source_table pg_catalog.name;\n    _source_schema pg_catalog.name;\n    _trigger_name pg_catalog.name;\n    _is_owner pg_catalog.bool;\n    _dimensions pg_catalog.int4;\n    _source_pk pg_catalog.jsonb;\n    _vectorizer_id pg_catalog.int4;\n    _existing_vectorizer_id pg_catalog.int4;\n    _sql pg_catalog.text;\n    _job_id pg_catalog.int8;\n    _queue_failed_table pg_catalog.name;\nbegin\n    -- make sure all the roles listed in grant_to exist\n    if grant_to is not null then\n        select\n          pg_catalog.array_agg(r) filter (where r operator(pg_catalog.!=) 'public' and pg_catalog.to_regrole(r) is null) -- missing\n        , pg_catalog.array_agg(r) filter (where r operator(pg_catalog.=) 'public' or pg_catalog.to_regrole(r) is not null) -- real roles\n        into strict\n          _missing_roles\n        , grant_to\n        from pg_catalog.unnest(grant_to) r\n        ;\n        if pg_catalog.array_length(_missing_roles, 1) operator(pg_catalog.>) 0 then\n            raise warning 'one or more grant_to roles do not exist: %', _missing_roles;\n        end if;\n    end if;\n\n    if embedding is null then\n        raise exception 'embedding configuration is required';\n    end if;\n\n    if loading is null then\n        raise exception 'loading configuration is required';\n    end if;\n\n    -- get source table name and schema name\n    select\n      k.relname\n    , n.nspname\n    , pg_catalog.pg_has_role(pg_catalog.current_user(), k.relowner, 'MEMBER')\n    into strict _source_table, _source_schema, _is_owner\n    from pg_catalog.pg_class k\n    inner join pg_catalog.pg_namespace n on (k.relnamespace operator(pg_catalog.=) n.oid)\n    where k.oid operator(pg_catalog.=) source\n    ;\n    -- not an owner of the table, but superuser?\n    if not _is_owner then\n        select r.rolsuper into strict _is_owner\n        from pg_catalog.pg_roles r\n        where r.rolname operator(pg_catalog.=) pg_catalog.current_user()\n        ;\n    end if;\n\n    if not _is_owner then\n        raise exception 'only a superuser or the owner of the source table may create a vectorizer on it';\n    end if;\n\n    select (embedding operator(pg_catalog.->) 'dimensions')::pg_catalog.int4 into _dimensions;\n    if _dimensions is null then\n        raise exception 'dimensions argument is required';\n    end if;\n\n    -- get the source table's primary key definition\n    select ai._vectorizer_source_pk(source) into strict _source_pk;\n    if _source_pk is null or pg_catalog.jsonb_array_length(_source_pk) operator(pg_catalog.=) 0 then\n        raise exception 'source table must have a primary key constraint';\n    end if;\n\n    _vectorizer_id = pg_catalog.nextval('ai.vectorizer_id_seq'::pg_catalog.regclass);\n    _trigger_name = pg_catalog.concat('_vectorizer_src_trg_', _vectorizer_id);\n    queue_schema = coalesce(queue_schema, 'ai');\n    queue_table = coalesce(queue_table, pg_catalog.concat('_vectorizer_q_', _vectorizer_id));\n    _queue_failed_table = pg_catalog.concat('_vectorizer_q_failed_', _vectorizer_id);\n\n    -- make sure queue table name is available\n    if pg_catalog.to_regclass(pg_catalog.format('%I.%I', queue_schema, queue_table)) is not null then\n        raise exception 'an object named %.% already exists. specify an alternate queue_table explicitly', queue_schema, queue_table\n        using errcode = 'duplicate_object';\n    end if;\n\n    -- validate the loading config\n    perform ai._validate_loading(loading, _source_schema, _source_table);\n\n    -- validate the parsing config\n    perform ai._validate_parsing(\n        parsing,\n        loading,\n        _source_schema,\n        _source_table\n    );\n\n    -- validate the destination config\n    perform ai._validate_destination(destination, chunking);\n\n    -- validate the embedding config\n    perform ai._validate_embedding(embedding);\n\n    -- validate the chunking config\n    perform ai._validate_chunking(chunking);\n\n    -- if ai.indexing_default, resolve the default\n    if indexing operator(pg_catalog.->>) 'implementation' = 'default' then\n        indexing = ai._resolve_indexing_default();\n    end if;\n\n    -- validate the indexing config\n    perform ai._validate_indexing(indexing);\n\n    -- validate the formatting config\n    perform ai._validate_formatting(formatting, _source_schema, _source_table);\n\n    -- if ai.scheduling_default, resolve the default\n    if scheduling operator(pg_catalog.->>) 'implementation' = 'default' then\n        scheduling = ai._resolve_scheduling_default();\n    end if;\n\n    -- validate the scheduling config\n    perform ai._validate_scheduling(scheduling);\n\n    -- validate the processing config\n    perform ai._validate_processing(processing);\n\n    -- if scheduling is none then indexing must also be none\n    if scheduling operator(pg_catalog.->>) 'implementation' = 'none'\n    and indexing operator(pg_catalog.->>) 'implementation' != 'none' then\n        raise exception 'automatic indexing is not supported without scheduling. set indexing=>ai.indexing_none() when scheduling=>ai.scheduling_none()';\n    end if;\n\n    -- evaluate the destination config\n    destination = ai._evaluate_destination(destination, _source_schema, _source_table);\n\n    if name is null then\n        if destination operator(pg_catalog.->>) 'implementation' = 'table' then\n            name = pg_catalog.format('%s_%s', destination operator(pg_catalog.->>) 'target_schema', destination operator(pg_catalog.->>) 'target_table');\n        elseif destination operator(pg_catalog.->>) 'implementation' = 'column' then\n            name = pg_catalog.format('%s_%s_%s', _source_schema, _source_table, destination operator(pg_catalog.->>) 'embedding_column');\n        end if;\n    end if;\n\n    -- validate the name is available\n    select id from ai.vectorizer\n    where ai.vectorizer.name operator(pg_catalog.=) create_vectorizer.name\n    into _existing_vectorizer_id\n    ;\n    if _existing_vectorizer_id is not null then\n        if if_not_exists is false then\n            raise exception 'a vectorizer named % already exists.', name\n            using errcode = 'duplicate_object';\n        end if;\n        raise notice 'a vectorizer named % already exists, skipping', name;\n        return _existing_vectorizer_id;\n    end if;\n\n    -- validate the destination can create objects after the if_not_exists check\n    perform ai._validate_destination_can_create_objects(destination);\n\n    -- grant select to source table\n    perform ai._vectorizer_grant_to_source\n    ( _source_schema\n    , _source_table\n    , grant_to\n    );\n\n    -- create the target table or column\n    if destination operator(pg_catalog.->>) 'implementation' = 'table' then\n        perform ai._vectorizer_create_destination_table\n        ( _source_schema\n        , _source_table\n        , _source_pk\n        , _dimensions\n        , destination\n        , grant_to\n        );\n    elseif destination operator(pg_catalog.->>) 'implementation' = 'column' then\n        perform ai._vectorizer_create_destination_column\n        ( _source_schema\n        , _source_table\n        , _dimensions\n        , destination\n        );\n    else\n        raise exception 'invalid implementation for destination';\n    end if;\n\n    -- create queue table\n    perform ai._vectorizer_create_queue_table\n    ( queue_schema\n    , queue_table\n    , _source_pk\n    , grant_to\n    );\n\n    -- create queue failed table\n    perform ai._vectorizer_create_queue_failed_table\n    ( queue_schema\n    , _queue_failed_table\n    , _source_pk\n    , grant_to\n    );\n\n    -- create trigger on source table to populate queue\n    perform ai._vectorizer_create_source_trigger\n    ( _trigger_name\n    , queue_schema\n    , queue_table\n    , _source_schema\n    , _source_table\n    , destination operator(pg_catalog.->>) 'target_schema'\n    , destination operator(pg_catalog.->>) 'target_table'\n    , _source_pk\n    );\n\n\n    -- schedule the async ext job\n    select ai._vectorizer_schedule_job\n    (_vectorizer_id\n    , scheduling\n    ) into _job_id\n    ;\n    if _job_id is not null then\n        scheduling = pg_catalog.jsonb_insert(scheduling, array['job_id'], pg_catalog.to_jsonb(_job_id));\n    end if;\n\n    insert into ai.vectorizer\n    ( id\n    , source_schema\n    , source_table\n    , source_pk\n    , trigger_name\n    , queue_schema\n    , queue_table\n    , queue_failed_table\n    , config\n    , name\n    )\n    values\n    ( _vectorizer_id\n    , _source_schema\n    , _source_table\n    , _source_pk\n    , _trigger_name\n    , queue_schema\n    , queue_table\n    , _queue_failed_table\n    , pg_catalog.jsonb_build_object\n      ( 'version', '0.12.1'\n      , 'loading', loading\n      , 'parsing', parsing\n      , 'embedding', embedding\n      , 'chunking', chunking\n      , 'indexing', indexing\n      , 'formatting', formatting\n      , 'scheduling', scheduling\n      , 'processing', processing\n      , 'destination', destination\n      )\n    , create_vectorizer.name\n    );\n\n    -- grant select on the vectorizer table\n    perform ai._vectorizer_grant_to_vectorizer(grant_to);\n\n    -- insert into queue any existing rows from source table\n    if enqueue_existing is true then\n        select pg_catalog.format\n        ( $sql$\n        insert into %I.%I (%s)\n        select %s\n        from %I.%I x\n        ;\n        $sql$\n        , queue_schema, queue_table\n        , (\n            select pg_catalog.string_agg(pg_catalog.format('%I', x.attname), ', ' order by x.attnum)\n            from pg_catalog.jsonb_to_recordset(_source_pk) x(attnum int, attname name)\n          )\n        , (\n            select pg_catalog.string_agg(pg_catalog.format('x.%I', x.attname), ', ' order by x.attnum)\n            from pg_catalog.jsonb_to_recordset(_source_pk) x(attnum int, attname name)\n          )\n        , _source_schema, _source_table\n        ) into strict _sql\n        ;\n        execute _sql;\n    end if;\n    return _vectorizer_id;\nend\n$function$\n",
      "description": null,
      "arguments": "source regclass, name text DEFAULT NULL::text, destination jsonb DEFAULT ai.destination_table(), loading jsonb DEFAULT NULL::jsonb, parsing jsonb DEFAULT ai.parsing_auto(), embedding jsonb DEFAULT NULL::jsonb, chunking jsonb DEFAULT ai.chunking_recursive_character_text_splitter(), indexing jsonb DEFAULT ai.indexing_default(), formatting jsonb DEFAULT ai.formatting_python_template(), scheduling jsonb DEFAULT ai.scheduling_default(), processing jsonb DEFAULT ai.processing_default(), queue_schema name DEFAULT NULL::name, queue_table name DEFAULT NULL::name, grant_to name[] DEFAULT ai.grant_to(), enqueue_existing boolean DEFAULT true, if_not_exists boolean DEFAULT false",
      "return_type": "integer",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18929,
      "name": "destination_column",
      "definition": "CREATE OR REPLACE FUNCTION ai.destination_column(embedding_column name)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_strip_nulls(json_build_object\n    ( 'implementation', 'column'\n    , 'config_type', 'destination'\n    , 'embedding_column', embedding_column\n    ))\n$function$\n",
      "description": null,
      "arguments": "embedding_column name",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18928,
      "name": "destination_table",
      "definition": "CREATE OR REPLACE FUNCTION ai.destination_table(destination name DEFAULT NULL::name, target_schema name DEFAULT NULL::name, target_table name DEFAULT NULL::name, view_schema name DEFAULT NULL::name, view_name name DEFAULT NULL::name)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_strip_nulls(json_build_object\n    ( 'implementation', 'table'\n    , 'config_type', 'destination'\n    , 'destination', destination\n    , 'target_schema', target_schema\n    , 'target_table', target_table\n    , 'view_schema', view_schema\n    , 'view_name', view_name\n    ))\n$function$\n",
      "description": null,
      "arguments": "destination name DEFAULT NULL::name, target_schema name DEFAULT NULL::name, target_table name DEFAULT NULL::name, view_schema name DEFAULT NULL::name, view_name name DEFAULT NULL::name",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18953,
      "name": "disable_vectorizer_schedule",
      "definition": "CREATE OR REPLACE FUNCTION ai.disable_vectorizer_schedule(vectorizer_id integer)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _vec ai.vectorizer%rowtype;\n    _schedule pg_catalog.jsonb;\n    _job_id pg_catalog.int8;\n    _sql pg_catalog.text;\nbegin\n    update ai.vectorizer v\n    set disabled = true\n    where v.id operator(pg_catalog.=) vectorizer_id\n    returning * into strict _vec\n    ;\n\n    -- enable the scheduled job if exists\n    _schedule = _vec.config operator(pg_catalog.->) 'scheduling';\n    if _schedule is not null then\n        case _schedule operator(pg_catalog.->>) 'implementation'\n            when 'none' then -- ok\n            when 'timescaledb' then\n                _job_id = (_schedule operator(pg_catalog.->) 'job_id')::pg_catalog.int8;\n                select pg_catalog.format\n                ( $$select %I.alter_job(job_id, scheduled=>false) from timescaledb_information.jobs where job_id = %L$$\n                , n.nspname\n                , _job_id\n                ) into _sql\n                from pg_catalog.pg_extension x\n                inner join pg_catalog.pg_namespace n on (x.extnamespace = n.oid)\n                where x.extname = 'timescaledb'\n                ;\n                if _sql is not null then\n                    execute _sql;\n                end if;\n        end case;\n    end if;\nend;\n$function$\n",
      "description": null,
      "arguments": "vectorizer_id integer",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18954,
      "name": "disable_vectorizer_schedule",
      "definition": "CREATE OR REPLACE FUNCTION ai.disable_vectorizer_schedule(name text)\n RETURNS void\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n   select ai.disable_vectorizer_schedule(v.id)\n   from ai.vectorizer v\n   where v.name operator(pg_catalog.=) disable_vectorizer_schedule.name;\n$function$\n",
      "description": null,
      "arguments": "name text",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18978,
      "name": "drop_semantic_catalog",
      "definition": "CREATE OR REPLACE FUNCTION ai.drop_semantic_catalog(catalog_name name)\n RETURNS integer\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _catalog_name name = drop_semantic_catalog.catalog_name;\n    _catalog_id int4;\n    _sql text;\n    _tbl text;\nbegin\n    delete from ai.semantic_catalog c\n    where c.catalog_name = _catalog_name\n    returning c.id into strict _catalog_id\n    ;\n\n    -- drop the table for database objects\n    _sql = format\n    ( $sql$\n        drop table if exists ai.semantic_catalog_obj_%s\n      $sql$\n    , _catalog_id\n    );\n    raise debug '%', _sql;\n    execute _sql;\n    \n    -- drop the table for example sql\n    _sql = format\n    ( $sql$\n        drop table if exists ai.semantic_catalog_sql_%s\n      $sql$\n    , _catalog_id\n    );\n    raise debug '%', _sql;\n    execute _sql;\n    \n    -- drop the table for facts\n    _sql = format\n    ( $sql$\n        drop table if exists ai.semantic_catalog_fact_%s\n      $sql$\n    , _catalog_id\n    );\n    raise debug '%', _sql;\n    execute _sql;\n    \n    -- drop trigger functions\n    for _tbl in (values ('obj', 'sql', 'fact'))\n    loop\n        _sql = format\n        ( $sql$\n            drop function if exists ai.semantic_catalog_%s_%s_trig()\n          $sql$\n        , _tbl\n        , _catalog_id\n        );\n        raise debug '%', _sql;\n        execute _sql;\n    end loop;\n    \n    return _catalog_id;\nend\n$function$\n",
      "description": null,
      "arguments": "catalog_name name",
      "return_type": "integer",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18957,
      "name": "drop_vectorizer",
      "definition": "CREATE OR REPLACE FUNCTION ai.drop_vectorizer(vectorizer_id integer, drop_all boolean DEFAULT false)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n/* drop_vectorizer\nThis function does the following:\n1. deletes the scheduled job if any\n2. drops the trigger from the source table\n3. drops the trigger function\n4. drops the queue table\n5. deletes the vectorizer row\n\nUNLESS drop_all = true, it does NOT:\n1. drop the target table containing the embeddings\n2. drop the view joining the target and source\n*/\ndeclare\n    _vec ai.vectorizer%rowtype;\n    _schedule pg_catalog.jsonb;\n    _job_id pg_catalog.int8;\n    _trigger pg_catalog.pg_trigger%rowtype;\n    _sql pg_catalog.text;\nbegin\n    -- grab the vectorizer we need to drop\n    select v.* into strict _vec\n    from ai.vectorizer v\n    where v.id operator(pg_catalog.=) vectorizer_id\n    ;\n\n    -- delete the scheduled job if exists\n    _schedule = _vec.config operator(pg_catalog.->) 'scheduling';\n    if _schedule is not null then\n        case _schedule operator(pg_catalog.->>) 'implementation'\n            when 'none' then -- ok\n            when 'timescaledb' then\n                _job_id = (_schedule operator(pg_catalog.->) 'job_id')::pg_catalog.int8;\n                select pg_catalog.format\n                ( $$select %I.delete_job(job_id) from timescaledb_information.jobs where job_id = %L$$\n                , n.nspname\n                , _job_id\n                ) into _sql\n                from pg_catalog.pg_extension x\n                inner join pg_catalog.pg_namespace n on (x.extnamespace operator(pg_catalog.=) n.oid)\n                where x.extname operator(pg_catalog.=) 'timescaledb'\n                ;\n                if found then\n                    execute _sql;\n                end if;\n        end case;\n    end if;\n\n    -- try to look up the trigger so we can find the function/procedure backing the trigger\n    select * into _trigger\n    from pg_catalog.pg_trigger g\n    inner join pg_catalog.pg_class k\n    on (g.tgrelid operator(pg_catalog.=) k.oid\n    and k.relname operator(pg_catalog.=) _vec.source_table)\n    inner join pg_catalog.pg_namespace n\n    on (k.relnamespace operator(pg_catalog.=) n.oid\n    and n.nspname operator(pg_catalog.=) _vec.source_schema)\n    where g.tgname operator(pg_catalog.=) _vec.trigger_name\n    ;\n\n    -- drop the trigger on the source table\n    if found then\n        select pg_catalog.format\n        ( $sql$drop trigger %I on %I.%I$sql$\n        , _trigger.tgname\n        , _vec.source_schema\n        , _vec.source_table\n        ) into strict _sql\n        ;\n        execute _sql;\n\n        select pg_catalog.format\n        ( $sql$drop trigger if exists %I on %I.%I$sql$\n        , format('%s_truncate', _trigger.tgname)\n        , _vec.source_schema\n        , _vec.source_table\n        ) into _sql;\n        execute _sql;\n\n        -- drop the function/procedure backing the trigger\n        select pg_catalog.format\n        ( $sql$drop %s %I.%I()$sql$\n        , case p.prokind when 'f' then 'function' when 'p' then 'procedure' end\n        , n.nspname\n        , p.proname\n        ) into _sql\n        from pg_catalog.pg_proc p\n        inner join pg_catalog.pg_namespace n on (n.oid operator(pg_catalog.=) p.pronamespace)\n        where p.oid operator(pg_catalog.=) _trigger.tgfoid\n        ;\n        if found then\n            execute _sql;\n        end if;\n    else\n        -- the trigger is missing. try to find the backing function by name and return type\n        select pg_catalog.format\n        ( $sql$drop %s %I.%I() cascade$sql$ -- cascade in case the trigger still exists somehow\n        , case p.prokind when 'f' then 'function' when 'p' then 'procedure' end\n        , n.nspname\n        , p.proname\n        ) into _sql\n        from pg_catalog.pg_proc p\n        inner join pg_catalog.pg_namespace n on (n.oid operator(pg_catalog.=) p.pronamespace)\n        inner join pg_catalog.pg_type y on (p.prorettype operator(pg_catalog.=) y.oid)\n        where n.nspname operator(pg_catalog.=) _vec.queue_schema\n        and p.proname operator(pg_catalog.=) _vec.trigger_name\n        and y.typname operator(pg_catalog.=) 'trigger'\n        ;\n        if found then\n            execute _sql;\n        end if;\n    end if;\n\n    -- drop the queue table if exists\n    select pg_catalog.format\n    ( $sql$drop table if exists %I.%I$sql$\n    , _vec.queue_schema\n    , _vec.queue_table\n    ) into strict _sql;\n    execute _sql;\n\n    -- drop the failed queue table if exists\n    select pg_catalog.format\n    ( $sql$drop table if exists %I.%I$sql$\n    , _vec.queue_schema\n    , _vec.queue_failed_table\n    ) into strict _sql;\n    execute _sql;\n\n    if drop_all and _vec.config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'implementation' operator(pg_catalog.=) 'table' then\n        -- drop the view if exists\n        select pg_catalog.format\n        ( $sql$drop view if exists %I.%I$sql$\n        , _vec.config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'view_schema'\n        , _vec.config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'view_name'\n        ) into strict _sql;\n        execute _sql;\n\n        -- drop the target table if exists\n        select pg_catalog.format\n        ( $sql$drop table if exists %I.%I$sql$\n        , _vec.config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'target_schema'\n        , _vec.config operator(pg_catalog.->) 'destination' operator(pg_catalog.->>) 'target_table'\n        ) into strict _sql;\n        execute _sql;\n    end if;\n\n    -- delete the vectorizer row\n    delete from ai.vectorizer v\n    where v.id operator(pg_catalog.=) vectorizer_id\n    ;\nend;\n$function$\n",
      "description": null,
      "arguments": "vectorizer_id integer, drop_all boolean DEFAULT false",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18958,
      "name": "drop_vectorizer",
      "definition": "CREATE OR REPLACE FUNCTION ai.drop_vectorizer(name text, drop_all boolean DEFAULT false)\n RETURNS void\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n   select ai.drop_vectorizer(v.id, drop_all)\n   from ai.vectorizer v\n   where v.name operator(pg_catalog.=) drop_vectorizer.name;\n$function$\n",
      "description": null,
      "arguments": "name text, drop_all boolean DEFAULT false",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18906,
      "name": "embedding_litellm",
      "definition": "CREATE OR REPLACE FUNCTION ai.embedding_litellm(model text, dimensions integer, api_key_name text DEFAULT NULL::text, extra_options jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\nbegin\n    return json_strip_nulls(json_build_object\n    ( 'implementation', 'litellm'\n    , 'config_type', 'embedding'\n    , 'model', model\n    , 'dimensions', dimensions\n    , 'api_key_name', api_key_name\n    , 'extra_options', extra_options\n    ));\nend\n$function$\n",
      "description": null,
      "arguments": "model text, dimensions integer, api_key_name text DEFAULT NULL::text, extra_options jsonb DEFAULT NULL::jsonb",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpgsql"
    },
    {
      "oid": 18904,
      "name": "embedding_ollama",
      "definition": "CREATE OR REPLACE FUNCTION ai.embedding_ollama(model text, dimensions integer, base_url text DEFAULT NULL::text, options jsonb DEFAULT NULL::jsonb, keep_alive text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_strip_nulls(json_build_object\n    ( 'implementation', 'ollama'\n    , 'config_type', 'embedding'\n    , 'model', model\n    , 'dimensions', dimensions\n    , 'base_url', base_url\n    , 'options', options\n    , 'keep_alive', keep_alive\n    ))\n$function$\n",
      "description": null,
      "arguments": "model text, dimensions integer, base_url text DEFAULT NULL::text, options jsonb DEFAULT NULL::jsonb, keep_alive text DEFAULT NULL::text",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18903,
      "name": "embedding_openai",
      "definition": "CREATE OR REPLACE FUNCTION ai.embedding_openai(model text, dimensions integer, chat_user text DEFAULT NULL::text, api_key_name text DEFAULT 'OPENAI_API_KEY'::text, base_url text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_strip_nulls(json_build_object\n    ( 'implementation', 'openai'\n    , 'config_type', 'embedding'\n    , 'model', model\n    , 'dimensions', dimensions\n    , 'user', chat_user\n    , 'api_key_name', api_key_name\n    , 'base_url', base_url\n    ))\n$function$\n",
      "description": null,
      "arguments": "model text, dimensions integer, chat_user text DEFAULT NULL::text, api_key_name text DEFAULT 'OPENAI_API_KEY'::text, base_url text DEFAULT NULL::text",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18973,
      "name": "embedding_sentence_transformers",
      "definition": "CREATE OR REPLACE FUNCTION ai.embedding_sentence_transformers(model text DEFAULT 'nomic-ai/nomic-embed-text-v1.5'::text, dimensions integer DEFAULT 768)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_build_object\n    ( 'implementation', 'sentence_transformers'\n    , 'config_type', 'embedding'\n    , 'model', model\n    , 'dimensions', dimensions\n    )\n$function$\n",
      "description": null,
      "arguments": "model text DEFAULT 'nomic-ai/nomic-embed-text-v1.5'::text, dimensions integer DEFAULT 768",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18905,
      "name": "embedding_voyageai",
      "definition": "CREATE OR REPLACE FUNCTION ai.embedding_voyageai(model text, dimensions integer, input_type text DEFAULT 'document'::text, api_key_name text DEFAULT 'VOYAGE_API_KEY'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\nbegin\n    if input_type is not null and input_type not in ('query', 'document') then\n        -- Note: purposefully not using an enum here because types make life complicated\n        raise exception 'invalid input_type for voyage ai \"%\"', input_type;\n    end if;\n\n    return json_strip_nulls(json_build_object\n    ( 'implementation', 'voyageai'\n    , 'config_type', 'embedding'\n    , 'model', model\n    , 'dimensions', dimensions\n    , 'input_type', input_type\n    , 'api_key_name', api_key_name\n    ));\nend\n$function$\n",
      "description": null,
      "arguments": "model text, dimensions integer, input_type text DEFAULT 'document'::text, api_key_name text DEFAULT 'VOYAGE_API_KEY'::text",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpgsql"
    },
    {
      "oid": 18955,
      "name": "enable_vectorizer_schedule",
      "definition": "CREATE OR REPLACE FUNCTION ai.enable_vectorizer_schedule(vectorizer_id integer)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _vec ai.vectorizer%rowtype;\n    _schedule pg_catalog.jsonb;\n    _job_id pg_catalog.int8;\n    _sql pg_catalog.text;\nbegin\n    update ai.vectorizer v\n    set disabled = false\n    where v.id operator(pg_catalog.=) vectorizer_id\n    returning * into strict _vec\n    ;\n\n    -- enable the scheduled job if exists\n    _schedule = _vec.config operator(pg_catalog.->) 'scheduling';\n    if _schedule is not null then\n        case _schedule operator(pg_catalog.->>) 'implementation'\n            when 'none' then -- ok\n            when 'timescaledb' then\n                _job_id = (_schedule operator(pg_catalog.->) 'job_id')::pg_catalog.int8;\n                select pg_catalog.format\n                ( $$select %I.alter_job(job_id, scheduled=>true) from timescaledb_information.jobs where job_id = %L$$\n                , n.nspname\n                , _job_id\n                ) into _sql\n                from pg_catalog.pg_extension x\n                inner join pg_catalog.pg_namespace n on (x.extnamespace operator(pg_catalog.=) n.oid)\n                where x.extname operator(pg_catalog.=) 'timescaledb'\n                ;\n                if _sql is not null then\n                    execute _sql;\n                end if;\n        end case;\n    end if;\nend;\n$function$\n",
      "description": null,
      "arguments": "vectorizer_id integer",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18956,
      "name": "enable_vectorizer_schedule",
      "definition": "CREATE OR REPLACE FUNCTION ai.enable_vectorizer_schedule(name text)\n RETURNS void\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n   select ai.enable_vectorizer_schedule(v.id)\n   from ai.vectorizer v\n   where v.name operator(pg_catalog.=) enable_vectorizer_schedule.name;\n$function$\n",
      "description": null,
      "arguments": "name text",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18950,
      "name": "execute_vectorizer",
      "definition": "CREATE OR REPLACE FUNCTION ai.execute_vectorizer(vectorizer_name text)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _vectorizer_id pg_catalog.int4;\nbegin\n    select v.id into strict _vectorizer_id\n    from ai.vectorizer v\n    where v.name operator(pg_catalog.=) vectorizer_name;\n\n    -- execute the vectorizer\n    perform ai.execute_vectorizer(_vectorizer_id);\nend\n$function$\n",
      "description": null,
      "arguments": "vectorizer_name text",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 19161,
      "name": "execute_vectorizer",
      "definition": "CREATE OR REPLACE FUNCTION ai.execute_vectorizer(vectorizer_id integer)\n RETURNS void\n LANGUAGE plpython3u\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.vectorizer\n    ai.vectorizer.execute_vectorizer(plpy, vectorizer_id)\n$function$\n",
      "description": null,
      "arguments": "vectorizer_id integer",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 18895,
      "name": "formatting_python_template",
      "definition": "CREATE OR REPLACE FUNCTION ai.formatting_python_template(template text DEFAULT '$chunk'::text)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_strip_nulls(json_build_object\n    ( 'implementation', 'python_template'\n    , 'config_type', 'formatting'\n    , 'template', template\n    ))\n$function$\n",
      "description": null,
      "arguments": "template text DEFAULT '$chunk'::text",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 19177,
      "name": "grant_ai_usage",
      "definition": "CREATE OR REPLACE FUNCTION ai.grant_ai_usage(to_user name, admin boolean DEFAULT false)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _sql pg_catalog.text;\nbegin\n    -- schema\n    select pg_catalog.format\n    ( 'grant %s on schema ai to %I%s'\n    , case when admin then 'all privileges' else 'usage, create' end\n    , to_user\n    , case when admin then ' with grant option' else '' end\n    ) into strict _sql\n    ;\n    raise debug '%', _sql;\n    execute _sql;\n\n    -- tables, sequences, and views\n    for _sql in\n    (\n        select pg_catalog.format\n        ( 'grant %s on %s %I.%I to %I%s'\n        , case\n            when admin then 'all privileges'\n            else\n                case\n                    when k.relname operator(pg_catalog.=) 'semantic_catalog' then 'select'\n                    when k.relkind in ('r', 'p') then 'select, insert, update, delete'\n                    when k.relkind in ('S') then 'usage, select, update'\n                    when k.relkind in ('v') then 'select'\n                end\n          end\n        , case\n            when k.relkind in ('r', 'p') then 'table'\n            when k.relkind in ('S') then 'sequence'\n            when k.relkind in ('v') then ''\n          end\n        , n.nspname\n        , k.relname\n        , to_user\n        , case when admin then ' with grant option' else '' end\n        )\n        from pg_catalog.pg_depend d\n        inner join pg_catalog.pg_extension e on (d.refobjid operator(pg_catalog.=) e.oid)\n        inner join pg_catalog.pg_class k on (d.objid operator(pg_catalog.=) k.oid)\n        inner join pg_namespace n on (k.relnamespace operator(pg_catalog.=) n.oid)\n        where d.refclassid operator(pg_catalog.=) 'pg_catalog.pg_extension'::pg_catalog.regclass\n        and d.deptype operator(pg_catalog.=) 'e'\n        and e.extname operator(pg_catalog.=) 'ai'\n        and k.relkind in ('r', 'p', 'S', 'v') -- tables, sequences, and views\n        and (admin, n.nspname, k.relname) not in\n        ( (false, 'ai', 'migration') -- only admins get any access to this table\n        , (false, 'ai', '_secret_permissions') -- only admins get any access to this table\n        , (false, 'ai', 'feature_flag') -- only admins get any access to this table\n        )\n        order by n.nspname, k.relname\n    )\n    loop\n        raise debug '%', _sql;\n        execute _sql;\n    end loop;\n\n    -- procedures and functions\n    for _sql in\n    (\n        select pg_catalog.format\n        ( 'grant %s on %s %I.%I(%s) to %I%s'\n        , case when admin then 'all privileges' else 'execute' end\n        , case k.prokind\n              when 'f' then 'function'\n              when 'p' then 'procedure'\n          end\n        , n.nspname\n        , k.proname\n        , pg_catalog.pg_get_function_identity_arguments(k.oid)\n        , to_user\n        , case when admin then ' with grant option' else '' end\n        )\n        from pg_catalog.pg_depend d\n        inner join pg_catalog.pg_extension e on (d.refobjid operator(pg_catalog.=) e.oid)\n        inner join pg_catalog.pg_proc k on (d.objid operator(pg_catalog.=) k.oid)\n        inner join pg_namespace n on (k.pronamespace operator(pg_catalog.=) n.oid)\n        where d.refclassid operator(pg_catalog.=) 'pg_catalog.pg_extension'::pg_catalog.regclass\n        and d.deptype operator(pg_catalog.=) 'e'\n        and e.extname operator(pg_catalog.=) 'ai'\n        and k.prokind in ('f', 'p')\n        and case\n              when k.proname in\n                ( 'grant_ai_usage'\n                , 'grant_secret'\n                , 'revoke_secret'\n                , 'post_restore'\n                , 'create_semantic_catalog'\n                )\n              then admin -- only admins get these function\n              else true\n            end\n    )\n    loop\n        raise debug '%', _sql;\n        execute _sql;\n    end loop;\n    \n    -- secret permissions\n    if admin then\n        -- grant access to all secrets to admin users\n        insert into ai._secret_permissions (\"name\", \"role\")\n        values ('*', to_user)\n        on conflict on constraint _secret_permissions_pkey\n        do nothing\n        ;\n    end if;\nend\n$function$\n",
      "description": null,
      "arguments": "to_user name, admin boolean DEFAULT false",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 19167,
      "name": "grant_secret",
      "definition": "CREATE OR REPLACE FUNCTION ai.grant_secret(secret_name text, grant_to_role text)\n RETURNS void\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    insert into ai._secret_permissions (\"name\", \"role\") values (secret_name, grant_to_role);\n$function$\n",
      "description": null,
      "arguments": "secret_name text, grant_to_role text",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18918,
      "name": "grant_to",
      "definition": "CREATE OR REPLACE FUNCTION ai.grant_to(VARIADIC grantees name[])\n RETURNS name[]\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select coalesce(pg_catalog.array_agg(cast(x as pg_catalog.name)), array[]::pg_catalog.name[])\n    from (\n        select pg_catalog.unnest(grantees) x\n        union\n        select trim(pg_catalog.string_to_table(pg_catalog.current_setting('ai.grant_to_default', true), ',')) x\n    ) _;\n$function$\n",
      "description": null,
      "arguments": "VARIADIC grantees name[]",
      "return_type": "name[]",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18919,
      "name": "grant_to",
      "definition": "CREATE OR REPLACE FUNCTION ai.grant_to()\n RETURNS name[]\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select ai.grant_to(variadic array[]::pg_catalog.name[])\n$function$\n",
      "description": null,
      "arguments": "",
      "return_type": "name[]",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 19004,
      "name": "grant_vectorizer_usage",
      "definition": "CREATE OR REPLACE FUNCTION ai.grant_vectorizer_usage(to_user name, admin boolean DEFAULT false)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\nbegin\n    if not admin then\n        execute 'grant usage, create on schema ai to ' || to_user;\n        execute 'grant select, insert, update, delete on table ai.vectorizer to ' || to_user;\n        execute 'grant select on ai._vectorizer_errors to ' || to_user;\n        execute 'grant select on ai.vectorizer_errors to ' || to_user;\n        execute 'grant select on ai.vectorizer_status to ' || to_user;\n        execute 'grant select, usage on sequence ai.vectorizer_id_seq to ' || to_user;\n    else\n        execute 'grant all privileges on schema ai to ' || to_user;\n        execute 'grant all privileges on table ai.pgai_lib_migration to ' || to_user;\n        execute 'grant all privileges on table ai.pgai_lib_version to ' || to_user;\n        execute 'grant all privileges on table ai.pgai_lib_feature_flag to ' || to_user;\n        execute 'grant all privileges on table ai.vectorizer to ' || to_user;\n        execute 'grant all privileges on table ai._vectorizer_errors to ' || to_user;\n        execute 'grant all privileges on table ai.vectorizer_errors to ' || to_user;\n        execute 'grant all privileges on table ai.vectorizer_status to ' || to_user;\n        execute 'grant all privileges on sequence ai.vectorizer_id_seq to ' || to_user;\n    end if;\nend\n$function$\n",
      "description": null,
      "arguments": "to_user name, admin boolean DEFAULT false",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18909,
      "name": "indexing_default",
      "definition": "CREATE OR REPLACE FUNCTION ai.indexing_default()\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select jsonb_build_object\n    ( 'implementation', 'default'\n    , 'config_type', 'indexing'\n    )\n$function$\n",
      "description": null,
      "arguments": "",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18910,
      "name": "indexing_diskann",
      "definition": "CREATE OR REPLACE FUNCTION ai.indexing_diskann(min_rows integer DEFAULT 100000, storage_layout text DEFAULT NULL::text, num_neighbors integer DEFAULT NULL::integer, search_list_size integer DEFAULT NULL::integer, max_alpha double precision DEFAULT NULL::double precision, num_dimensions integer DEFAULT NULL::integer, num_bits_per_dimension integer DEFAULT NULL::integer, create_when_queue_empty boolean DEFAULT true)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_strip_nulls(json_build_object\n    ( 'implementation', 'diskann'\n    , 'config_type', 'indexing'\n    , 'min_rows', min_rows\n    , 'storage_layout', storage_layout\n    , 'num_neighbors', num_neighbors\n    , 'search_list_size', search_list_size\n    , 'max_alpha', max_alpha\n    , 'num_dimensions', num_dimensions\n    , 'num_bits_per_dimension', num_bits_per_dimension\n    , 'create_when_queue_empty', create_when_queue_empty\n    ))\n$function$\n",
      "description": null,
      "arguments": "min_rows integer DEFAULT 100000, storage_layout text DEFAULT NULL::text, num_neighbors integer DEFAULT NULL::integer, search_list_size integer DEFAULT NULL::integer, max_alpha double precision DEFAULT NULL::double precision, num_dimensions integer DEFAULT NULL::integer, num_bits_per_dimension integer DEFAULT NULL::integer, create_when_queue_empty boolean DEFAULT true",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18913,
      "name": "indexing_hnsw",
      "definition": "CREATE OR REPLACE FUNCTION ai.indexing_hnsw(min_rows integer DEFAULT 100000, opclass text DEFAULT 'vector_cosine_ops'::text, m integer DEFAULT NULL::integer, ef_construction integer DEFAULT NULL::integer, create_when_queue_empty boolean DEFAULT true)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_strip_nulls(json_build_object\n    ( 'implementation', 'hnsw'\n    , 'config_type', 'indexing'\n    , 'min_rows', min_rows\n    , 'opclass', opclass\n    , 'm', m\n    , 'ef_construction', ef_construction\n    , 'create_when_queue_empty', create_when_queue_empty\n    ))\n$function$\n",
      "description": null,
      "arguments": "min_rows integer DEFAULT 100000, opclass text DEFAULT 'vector_cosine_ops'::text, m integer DEFAULT NULL::integer, ef_construction integer DEFAULT NULL::integer, create_when_queue_empty boolean DEFAULT true",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18908,
      "name": "indexing_none",
      "definition": "CREATE OR REPLACE FUNCTION ai.indexing_none()\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select jsonb_build_object\n    ( 'implementation', 'none'\n    , 'config_type', 'indexing'\n    )\n$function$\n",
      "description": null,
      "arguments": "",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 19173,
      "name": "litellm_embed",
      "definition": "CREATE OR REPLACE FUNCTION ai.litellm_embed(model text, input_text text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, extra_options jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false)\n RETURNS vector\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.litellm\n    import ai.secrets\n    options = {}\n    if extra_options is not None:\n        import json\n        options = {k: v for k, v in json.loads(extra_options).items()}\n\n    if api_key is not None or api_key_name is not None:\n        api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, \"\", SD)\n    else:\n        api_key_resolved = None\n    \n    with ai.utils.VerboseRequestTrace(plpy, \"litellm.embed()\", verbose):\n        result = ai.litellm.embed(model, [input_text], api_key=api_key_resolved, **options)\n    \n    for tup in result:\n        return tup[1]\n$function$\n",
      "description": null,
      "arguments": "model text, input_text text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, extra_options jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false",
      "return_type": "vector",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19174,
      "name": "litellm_embed",
      "definition": "CREATE OR REPLACE FUNCTION ai.litellm_embed(model text, input_texts text[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, extra_options jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false)\n RETURNS TABLE(index integer, embedding vector)\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.litellm\n    import ai.secrets\n    options = {}\n    if extra_options is not None:\n        import json\n        options = {k: v for k, v in json.loads(extra_options).items()}\n\n    if api_key is not None or api_key_name is not None:\n        api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, \"\", SD)\n    else:\n        api_key_resolved = None\n    \n    with ai.utils.VerboseRequestTrace(plpy, \"litellm.embed()\", verbose):\n        result = ai.litellm.embed(model, input_texts, api_key=api_key_resolved, **options)\n    \n    for tup in result:\n        yield tup\n$function$\n",
      "description": null,
      "arguments": "model text, input_texts text[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, extra_options jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false",
      "return_type": "TABLE(index integer, embedding vector)",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19172,
      "name": "load_dataset",
      "definition": "CREATE OR REPLACE FUNCTION ai.load_dataset(name text, config_name text DEFAULT NULL::text, split text DEFAULT NULL::text, schema_name name DEFAULT 'public'::name, table_name name DEFAULT NULL::name, if_table_exists text DEFAULT 'error'::text, field_types jsonb DEFAULT NULL::jsonb, batch_size integer DEFAULT 5000, max_batches integer DEFAULT NULL::integer, kwargs jsonb DEFAULT '{}'::jsonb)\n RETURNS bigint\n LANGUAGE plpython3u\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    #ADD-PYTHON-LIB-DIR\n    import ai.load_dataset\n    import json\n    \n    # Convert kwargs from json string to dict\n    kwargs_dict = {}\n    if kwargs:\n        kwargs_dict = json.loads(kwargs)\n    \n    # Convert field_types from json string to dict\n    field_types_dict = None \n    if field_types:\n        field_types_dict = json.loads(field_types)\n    \n    return ai.load_dataset.load_dataset(\n        plpy,\n        name=name,\n        config_name=config_name,\n        split=split,\n        schema=schema_name,\n        table_name=table_name,\n        if_table_exists=if_table_exists,\n        field_types=field_types_dict,\n        batch_size=batch_size,\n        max_batches=max_batches,\n        commit_every_n_batches=None,\n        **kwargs_dict\n    )\n$function$\n",
      "description": null,
      "arguments": "name text, config_name text DEFAULT NULL::text, split text DEFAULT NULL::text, schema_name name DEFAULT 'public'::name, table_name name DEFAULT NULL::name, if_table_exists text DEFAULT 'error'::text, field_types jsonb DEFAULT NULL::jsonb, batch_size integer DEFAULT 5000, max_batches integer DEFAULT NULL::integer, kwargs jsonb DEFAULT '{}'::jsonb",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 19171,
      "name": "load_dataset_multi_txn",
      "definition": "CREATE OR REPLACE PROCEDURE ai.load_dataset_multi_txn(IN name text, IN config_name text DEFAULT NULL::text, IN split text DEFAULT NULL::text, IN schema_name name DEFAULT 'public'::name, IN table_name name DEFAULT NULL::name, IN if_table_exists text DEFAULT 'error'::text, IN field_types jsonb DEFAULT NULL::jsonb, IN batch_size integer DEFAULT 5000, IN max_batches integer DEFAULT NULL::integer, IN commit_every_n_batches integer DEFAULT 1, IN kwargs jsonb DEFAULT '{}'::jsonb)\n LANGUAGE plpython3u\nAS $procedure$\n    #ADD-PYTHON-LIB-DIR\n    import ai.load_dataset\n    import json\n     \n    # Convert kwargs from json string to dict\n    kwargs_dict = {}\n    if kwargs:\n        kwargs_dict = json.loads(kwargs)\n    \n    # Convert field_types from json string to dict\n    field_types_dict = None \n    if field_types:\n        field_types_dict = json.loads(field_types)\n    \n    \n    num_rows = ai.load_dataset.load_dataset(\n        plpy,\n        name=name,\n        config_name=config_name,\n        split=split,\n        schema=schema_name,\n        table_name=table_name,\n        if_table_exists=if_table_exists,\n        field_types=field_types_dict,\n        batch_size=batch_size,\n        max_batches=max_batches,\n        commit_every_n_batches=commit_every_n_batches,\n        **kwargs_dict\n    )\n$procedure$\n",
      "description": null,
      "arguments": "IN name text, IN config_name text DEFAULT NULL::text, IN split text DEFAULT NULL::text, IN schema_name name DEFAULT 'public'::name, IN table_name name DEFAULT NULL::name, IN if_table_exists text DEFAULT 'error'::text, IN field_types jsonb DEFAULT NULL::jsonb, IN batch_size integer DEFAULT 5000, IN max_batches integer DEFAULT NULL::integer, IN commit_every_n_batches integer DEFAULT 1, IN kwargs jsonb DEFAULT '{}'::jsonb",
      "return_type": null,
      "kind": "p",
      "kind_label": "procedure",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 18920,
      "name": "loading_column",
      "definition": "CREATE OR REPLACE FUNCTION ai.loading_column(column_name name, retries integer DEFAULT 6)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_build_object\n    ( 'implementation', 'column'\n    , 'config_type', 'loading'\n    , 'column_name', column_name\n    , 'retries', retries\n    )\n$function$\n",
      "description": null,
      "arguments": "column_name name, retries integer DEFAULT 6",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18921,
      "name": "loading_uri",
      "definition": "CREATE OR REPLACE FUNCTION ai.loading_uri(column_name name, retries integer DEFAULT 6, aws_role_arn text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_strip_nulls(json_build_object\n    ( 'implementation', 'uri'\n    , 'config_type', 'loading'\n    , 'column_name', column_name\n    , 'retries', retries\n    , 'aws_role_arn', aws_role_arn\n    ))\n$function$\n",
      "description": null,
      "arguments": "column_name name, retries integer DEFAULT 6, aws_role_arn text DEFAULT NULL::text",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 19147,
      "name": "ollama_chat_complete",
      "definition": "CREATE OR REPLACE FUNCTION ai.ollama_chat_complete(model text, messages jsonb, host text DEFAULT NULL::text, keep_alive text DEFAULT NULL::text, chat_options jsonb DEFAULT NULL::jsonb, tools jsonb DEFAULT NULL::jsonb, response_format jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE plpython3u\n PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import json\n    import ai.ollama\n    import ai.utils\n    client = ai.ollama.make_client(plpy, host)\n\n    import json\n    import base64\n    args = {}\n\n    if keep_alive is not None:\n        args[\"keep_alive\"] = keep_alive\n\n    if chat_options is not None:\n        args[\"options\"] = {k: v for k, v in json.loads(chat_options).items()}\n\n    if tools is not None:\n        args[\"tools\"] = json.loads(tools)\n\n    if response_format is not None:\n        args[\"format\"] = json.loads(response_format)\n\n    messages_1 = json.loads(messages)\n    if not isinstance(messages_1, list):\n        plpy.error(\"messages is not an array\")\n\n    # the python api expects bytes objects for images\n    # decode the base64 encoded images into raw binary\n    for message in messages_1:\n        if 'images' in message:\n            decoded = [base64.b64decode(image) for image in message[\"images\"]]\n            message[\"images\"] = decoded\n\n    with ai.utils.VerboseRequestTrace(plpy, \"ollama.chat()\", verbose):\n        resp = client.chat(model, messages_1, stream=False, **args)\n\n    return resp.model_dump_json()\n$function$\n",
      "description": null,
      "arguments": "model text, messages jsonb, host text DEFAULT NULL::text, keep_alive text DEFAULT NULL::text, chat_options jsonb DEFAULT NULL::jsonb, tools jsonb DEFAULT NULL::jsonb, response_format jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 19145,
      "name": "ollama_embed",
      "definition": "CREATE OR REPLACE FUNCTION ai.ollama_embed(model text, input_text text, host text DEFAULT NULL::text, keep_alive text DEFAULT NULL::text, embedding_options jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false)\n RETURNS vector\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.ollama\n    import ai.utils\n    client = ai.ollama.make_client(plpy, host)\n    embedding_options_1 = None\n    if embedding_options is not None:\n        import json\n        embedding_options_1 = {k: v for k, v in json.loads(embedding_options).items()}\n    with ai.utils.VerboseRequestTrace(plpy, \"ollama.embeddings()\", verbose):\n        resp = client.embeddings(model, input_text, options=embedding_options_1, keep_alive=keep_alive)\n    return resp.get(\"embedding\")\n$function$\n",
      "description": null,
      "arguments": "model text, input_text text, host text DEFAULT NULL::text, keep_alive text DEFAULT NULL::text, embedding_options jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false",
      "return_type": "vector",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19146,
      "name": "ollama_generate",
      "definition": "CREATE OR REPLACE FUNCTION ai.ollama_generate(model text, prompt text, host text DEFAULT NULL::text, images bytea[] DEFAULT NULL::bytea[], keep_alive text DEFAULT NULL::text, embedding_options jsonb DEFAULT NULL::jsonb, system_prompt text DEFAULT NULL::text, template text DEFAULT NULL::text, context integer[] DEFAULT NULL::integer[], \"verbose\" boolean DEFAULT false)\n RETURNS jsonb\n LANGUAGE plpython3u\n PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.ollama\n    import ai.utils\n    client = ai.ollama.make_client(plpy, host)\n\n    import json\n    args = {}\n\n    if keep_alive is not None:\n        args[\"keep_alive\"] = keep_alive\n\n    if embedding_options is not None:\n        args[\"options\"] = {k: v for k, v in json.loads(embedding_options).items()}\n\n    if system_prompt is not None:\n        args[\"system\"] = system_prompt\n\n    if template is not None:\n        args[\"template\"] = template\n\n    if context is not None:\n        args[\"context\"] = context\n\n    if images is not None:\n        import base64\n        images_1 = []\n        for image in images:\n            images_1.append(base64.b64encode(image).decode('utf-8'))\n        args[\"images\"] = images_1\n\n    with ai.utils.VerboseRequestTrace(plpy, \"ollama.generate()\", verbose):\n        resp = client.generate(model, prompt, stream=False, **args)\n    return resp.model_dump_json()\n$function$\n",
      "description": null,
      "arguments": "model text, prompt text, host text DEFAULT NULL::text, images bytea[] DEFAULT NULL::bytea[], keep_alive text DEFAULT NULL::text, embedding_options jsonb DEFAULT NULL::jsonb, system_prompt text DEFAULT NULL::text, template text DEFAULT NULL::text, context integer[] DEFAULT NULL::integer[], \"verbose\" boolean DEFAULT false",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 19143,
      "name": "ollama_list_models",
      "definition": "CREATE OR REPLACE FUNCTION ai.ollama_list_models(host text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false)\n RETURNS TABLE(name text, model text, size bigint, digest text, family text, format text, families jsonb, parent_model text, parameter_size text, quantization_level text, modified_at timestamp with time zone)\n LANGUAGE plpython3u\n PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.ollama\n    import ai.utils\n    client = ai.ollama.make_client(plpy, host)\n    import json\n    with ai.utils.VerboseRequestTrace(plpy, \"ollama.list()\", verbose):\n        resp = client.list()\n    models = resp.get(\"models\")\n    if models is None:\n        raise StopIteration\n    for m in models:\n        d = m.get(\"details\")\n        yield ( m.get(\"name\")\n            , m.get(\"model\")\n            , m.get(\"size\")\n            , m.get(\"digest\")\n            , d.get(\"family\") if d is not None else None\n            , d.get(\"format\") if d is not None else None\n            , json.dumps(d.get(\"families\")) if d is not None else None\n            , d.get(\"parent_model\") if d is not None else None\n            , d.get(\"parameter_size\") if d is not None else None\n            , d.get(\"quantization_level\") if d is not None else None\n            , m.get(\"modified_at\")\n        )\n$function$\n",
      "description": null,
      "arguments": "host text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false",
      "return_type": "TABLE(name text, model text, size bigint, digest text, family text, format text, families jsonb, parent_model text, parameter_size text, quantization_level text, modified_at timestamp with time zone)",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 19144,
      "name": "ollama_ps",
      "definition": "CREATE OR REPLACE FUNCTION ai.ollama_ps(host text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false)\n RETURNS TABLE(name text, model text, size bigint, digest text, parent_model text, format text, family text, families jsonb, parameter_size text, quantization_level text, expires_at timestamp with time zone, size_vram bigint)\n LANGUAGE plpython3u\n PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.ollama\n    import ai.utils\n    client = ai.ollama.make_client(plpy, host)\n    import json\n    with ai.utils.VerboseRequestTrace(plpy, \"ollama.ps()\", verbose):\n        resp = client.ps()\n    models = resp.get(\"models\")\n    if models is None:\n        raise StopIteration\n    for m in models:\n        d = m.get(\"details\")\n        yield ( m.get(\"name\")\n            , m.get(\"model\")\n            , m.get(\"size\")\n            , m.get(\"digest\")\n            , d.get(\"parent_model\") if d is not None else None\n            , d.get(\"format\") if d is not None else None\n            , d.get(\"family\") if d is not None else None\n            , json.dumps(d.get(\"families\")) if d is not None else None\n            , d.get(\"parameter_size\") if d is not None else None\n            , d.get(\"quantization_level\") if d is not None else None\n            , m.get(\"expires_at\")\n            , m.get(\"size_vram\")\n        )\n$function$\n",
      "description": null,
      "arguments": "host text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false",
      "return_type": "TABLE(name text, model text, size bigint, digest text, parent_model text, format text, family text, families jsonb, parameter_size text, quantization_level text, expires_at timestamp with time zone, size_vram bigint)",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 19135,
      "name": "openai_chat_complete",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_chat_complete(model text, messages jsonb, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, frequency_penalty double precision DEFAULT NULL::double precision, logit_bias jsonb DEFAULT NULL::jsonb, logprobs boolean DEFAULT NULL::boolean, top_logprobs integer DEFAULT NULL::integer, max_tokens integer DEFAULT NULL::integer, max_completion_tokens integer DEFAULT NULL::integer, n integer DEFAULT NULL::integer, presence_penalty double precision DEFAULT NULL::double precision, response_format jsonb DEFAULT NULL::jsonb, seed integer DEFAULT NULL::integer, stop text DEFAULT NULL::text, temperature double precision DEFAULT NULL::double precision, top_p double precision DEFAULT NULL::double precision, tools jsonb DEFAULT NULL::jsonb, tool_choice text DEFAULT NULL::text, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpython3u\n PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.openai\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.openai.DEFAULT_KEY_NAME, SD)\n    client = ai.openai.make_client(plpy, api_key_resolved, ai.openai.str_arg_to_dict(client_config))\n    import json\n\n    messages_1 = json.loads(messages)\n    if not isinstance(messages_1, list):\n        plpy.error(\"messages is not an array\")\n\n    kwargs = ai.openai.create_kwargs(\n        frequency_penalty=frequency_penalty,\n        logit_bias=ai.openai.str_arg_to_dict(logit_bias),\n        logprobs=logprobs,\n        top_logprobs=top_logprobs,\n        max_tokens=max_tokens,\n        max_completion_tokens=max_completion_tokens,\n        n=n,\n        presence_penalty=presence_penalty,\n        response_format=ai.openai.str_arg_to_dict(response_format),\n        seed=seed,\n        stop=stop,\n        temperature=temperature,\n        top_p=top_p,\n        tools=ai.openai.str_arg_to_dict(tools),\n        tool_choice=tool_choice if tool_choice in {'auto', 'none', 'required'} else ai.openai.str_arg_to_dict(tool_choice),\n        user=openai_user,\n        extra_headers=ai.openai.str_arg_to_dict(extra_headers),\n        extra_query=ai.openai.str_arg_to_dict(extra_query),\n        extra_body=ai.openai.str_arg_to_dict(extra_body))\n\n    with ai.utils.VerboseRequestTrace(plpy, \"openai.chat_complete()\", verbose):\n        response = client.chat.completions.create(\n          model=model\n        , messages=messages_1\n        , stream=False\n        , **kwargs\n        )\n\n    return response.model_dump_json()\n$function$\n",
      "description": null,
      "arguments": "model text, messages jsonb, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, frequency_penalty double precision DEFAULT NULL::double precision, logit_bias jsonb DEFAULT NULL::jsonb, logprobs boolean DEFAULT NULL::boolean, top_logprobs integer DEFAULT NULL::integer, max_tokens integer DEFAULT NULL::integer, max_completion_tokens integer DEFAULT NULL::integer, n integer DEFAULT NULL::integer, presence_penalty double precision DEFAULT NULL::double precision, response_format jsonb DEFAULT NULL::jsonb, seed integer DEFAULT NULL::integer, stop text DEFAULT NULL::text, temperature double precision DEFAULT NULL::double precision, top_p double precision DEFAULT NULL::double precision, tools jsonb DEFAULT NULL::jsonb, tool_choice text DEFAULT NULL::text, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 19139,
      "name": "openai_chat_complete_simple",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_chat_complete_simple(message text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb)\n RETURNS text\n LANGUAGE plpgsql\n PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    model text := 'gpt-4o';\n    messages jsonb;\nbegin\n    messages := pg_catalog.jsonb_build_array(\n        pg_catalog.jsonb_build_object('role', 'system', 'content', 'you are a helpful assistant'),\n        pg_catalog.jsonb_build_object('role', 'user', 'content', message)\n    );\n    return ai.openai_chat_complete(model, messages, api_key, api_key_name, verbose=>\"verbose\")\n        operator(pg_catalog.->)'choices'\n        operator(pg_catalog.->)0\n        operator(pg_catalog.->)'message'\n        operator(pg_catalog.->>)'content';\nend;\n$function$\n",
      "description": null,
      "arguments": "message text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb",
      "return_type": "text",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 19137,
      "name": "openai_chat_complete_with_raw_response",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_chat_complete_with_raw_response(model text, messages jsonb, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, frequency_penalty double precision DEFAULT NULL::double precision, logit_bias jsonb DEFAULT NULL::jsonb, logprobs boolean DEFAULT NULL::boolean, top_logprobs integer DEFAULT NULL::integer, max_tokens integer DEFAULT NULL::integer, max_completion_tokens integer DEFAULT NULL::integer, n integer DEFAULT NULL::integer, presence_penalty double precision DEFAULT NULL::double precision, response_format jsonb DEFAULT NULL::jsonb, seed integer DEFAULT NULL::integer, stop text DEFAULT NULL::text, temperature double precision DEFAULT NULL::double precision, top_p double precision DEFAULT NULL::double precision, tools jsonb DEFAULT NULL::jsonb, tool_choice text DEFAULT NULL::text, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpython3u\n PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.openai\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.openai.DEFAULT_KEY_NAME, SD)\n    client = ai.openai.make_client(plpy, api_key_resolved, ai.openai.str_arg_to_dict(client_config))\n    import json\n\n    messages_1 = json.loads(messages)\n    if not isinstance(messages_1, list):\n      plpy.error(\"messages is not an array\")\n\n    kwargs = ai.openai.create_kwargs(\n        frequency_penalty=frequency_penalty,\n        logit_bias=ai.openai.str_arg_to_dict(logit_bias),\n        logprobs=logprobs,\n        top_logprobs=top_logprobs,\n        max_tokens=max_tokens,\n        max_completion_tokens=max_completion_tokens,\n        n=n,\n        presence_penalty=presence_penalty,\n        response_format=ai.openai.str_arg_to_dict(response_format),\n        seed=seed,\n        stop=stop,\n        temperature=temperature,\n        top_p=top_p,\n        tools=ai.openai.str_arg_to_dict(tools),\n        tool_choice=tool_choice if tool_choice in {'auto', 'none', 'required'} else ai.openai.str_arg_to_dict(tool_choice),\n        user=openai_user,\n        extra_headers=ai.openai.str_arg_to_dict(extra_headers),\n        extra_query=ai.openai.str_arg_to_dict(extra_query),\n        extra_body=ai.openai.str_arg_to_dict(extra_body))\n\n    with ai.utils.VerboseRequestTrace(plpy, \"openai.chat_complete()\", verbose):\n        response = client.chat.completions.with_raw_response.create(\n            model=model,\n            messages=messages_1,\n            stream=False,\n            **kwargs)\n\n    return response.text\n$function$\n",
      "description": null,
      "arguments": "model text, messages jsonb, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, frequency_penalty double precision DEFAULT NULL::double precision, logit_bias jsonb DEFAULT NULL::jsonb, logprobs boolean DEFAULT NULL::boolean, top_logprobs integer DEFAULT NULL::integer, max_tokens integer DEFAULT NULL::integer, max_completion_tokens integer DEFAULT NULL::integer, n integer DEFAULT NULL::integer, presence_penalty double precision DEFAULT NULL::double precision, response_format jsonb DEFAULT NULL::jsonb, seed integer DEFAULT NULL::integer, stop text DEFAULT NULL::text, temperature double precision DEFAULT NULL::double precision, top_p double precision DEFAULT NULL::double precision, tools jsonb DEFAULT NULL::jsonb, tool_choice text DEFAULT NULL::text, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 19142,
      "name": "openai_client_config",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_client_config(base_url text DEFAULT NULL::text, timeout_seconds double precision DEFAULT NULL::double precision, organization text DEFAULT NULL::text, project text DEFAULT NULL::text, max_retries integer DEFAULT NULL::integer, default_headers jsonb DEFAULT NULL::jsonb, default_query jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpython3u\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.openai\n    import ai.secrets\n    import json\n\n    client_config = ai.openai.create_kwargs(\n        base_url=base_url,\n        timeout=timeout_seconds,\n        organization=organization,\n        project=project,\n        max_retries=max_retries,\n        default_headers=ai.openai.str_arg_to_dict(default_headers),\n        default_query=ai.openai.str_arg_to_dict(default_query),\n    )\n    return json.dumps(client_config)\n$function$\n",
      "description": null,
      "arguments": "base_url text DEFAULT NULL::text, timeout_seconds double precision DEFAULT NULL::double precision, organization text DEFAULT NULL::text, project text DEFAULT NULL::text, max_retries integer DEFAULT NULL::integer, default_headers jsonb DEFAULT NULL::jsonb, default_query jsonb DEFAULT NULL::jsonb",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19126,
      "name": "openai_detokenize",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_detokenize(model text, tokens integer[])\n RETURNS text\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE STRICT\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import tiktoken\n    encoding = tiktoken.encoding_for_model(model)\n    content = encoding.decode(tokens)\n    return content\n$function$\n",
      "description": null,
      "arguments": "model text, tokens integer[]",
      "return_type": "text",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19129,
      "name": "openai_embed",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_embed(model text, input_text text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, dimensions integer DEFAULT NULL::integer, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb)\n RETURNS vector\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.openai\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.openai.DEFAULT_KEY_NAME, SD)\n    with ai.utils.VerboseRequestTrace(plpy, \"openai.embed()\", verbose):\n        embeddings = ai.openai.embed(\n            plpy,\n            ai.openai.str_arg_to_dict(client_config),\n            model,\n            input_text,\n            api_key_resolved,\n            dimensions,\n            openai_user,\n            extra_headers,\n            extra_query,\n            extra_body)\n    for tup in embeddings:\n        return tup[1]\n$function$\n",
      "description": null,
      "arguments": "model text, input_text text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, dimensions integer DEFAULT NULL::integer, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb",
      "return_type": "vector",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19130,
      "name": "openai_embed",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_embed(model text, input_texts text[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, dimensions integer DEFAULT NULL::integer, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb)\n RETURNS TABLE(index integer, embedding vector)\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.openai\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.openai.DEFAULT_KEY_NAME, SD)\n    with ai.utils.VerboseRequestTrace(plpy, \"openai.embed()\", verbose):\n        embeddings = ai.openai.embed(\n            plpy,\n            ai.openai.str_arg_to_dict(client_config),\n            model,\n            input_texts,\n            api_key_resolved,\n            dimensions,\n            openai_user,\n            extra_headers,\n            extra_query,\n            extra_body)\n    for tup in embeddings:\n        yield tup\n$function$\n",
      "description": null,
      "arguments": "model text, input_texts text[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, dimensions integer DEFAULT NULL::integer, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb",
      "return_type": "TABLE(index integer, embedding vector)",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19131,
      "name": "openai_embed",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_embed(model text, input_tokens integer[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, dimensions integer DEFAULT NULL::integer, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb)\n RETURNS vector\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.openai\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.openai.DEFAULT_KEY_NAME, SD)\n    with ai.utils.VerboseRequestTrace(plpy, \"openai.embed()\", verbose):\n        embeddings = ai.openai.embed(\n            plpy,\n            ai.openai.str_arg_to_dict(client_config),\n            model,\n            input_tokens,\n            api_key_resolved,\n            dimensions,\n            openai_user,\n            extra_headers,\n            extra_query,\n            extra_body)\n    for tup in embeddings:\n        return tup[1]\n$function$\n",
      "description": null,
      "arguments": "model text, input_tokens integer[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, dimensions integer DEFAULT NULL::integer, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb",
      "return_type": "vector",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19132,
      "name": "openai_embed_with_raw_response",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_embed_with_raw_response(model text, input_text text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, dimensions integer DEFAULT NULL::integer, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.openai\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.openai.DEFAULT_KEY_NAME, SD)\n    with ai.utils.VerboseRequestTrace(plpy, \"openai.embed()\", verbose):\n        return ai.openai.embed_with_raw_response(\n            plpy,\n            ai.openai.str_arg_to_dict(client_config),\n            model,\n            input_text,\n            api_key_resolved,\n            dimensions,\n            openai_user,\n            extra_headers,\n            extra_query,\n            extra_body)\n$function$\n",
      "description": null,
      "arguments": "model text, input_text text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, dimensions integer DEFAULT NULL::integer, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19133,
      "name": "openai_embed_with_raw_response",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_embed_with_raw_response(model text, input_texts text[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, dimensions integer DEFAULT NULL::integer, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.openai\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.openai.DEFAULT_KEY_NAME, SD)\n    with ai.utils.VerboseRequestTrace(plpy, \"openai.embed()\", verbose):\n        return ai.openai.embed_with_raw_response(\n            plpy,\n            ai.openai.str_arg_to_dict(client_config),\n            model,\n            input_texts,\n            api_key_resolved,\n            dimensions,\n            openai_user,\n            extra_headers,\n            extra_query,\n            extra_body)\n$function$\n",
      "description": null,
      "arguments": "model text, input_texts text[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, dimensions integer DEFAULT NULL::integer, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19134,
      "name": "openai_embed_with_raw_response",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_embed_with_raw_response(model text, input_tokens integer[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, dimensions integer DEFAULT NULL::integer, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.openai\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.openai.DEFAULT_KEY_NAME, SD)\n    with ai.utils.VerboseRequestTrace(plpy, \"openai.embed()\", verbose):\n        return ai.openai.embed_with_raw_response(\n            plpy,\n            ai.openai.str_arg_to_dict(client_config),\n            model,\n            input_tokens,\n            api_key_resolved,\n            dimensions,\n            openai_user,\n            extra_headers,\n            extra_query,\n            extra_body)\n$function$\n",
      "description": null,
      "arguments": "model text, input_tokens integer[], api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, dimensions integer DEFAULT NULL::integer, openai_user text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19127,
      "name": "openai_list_models",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_list_models(api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb)\n RETURNS TABLE(id text, created timestamp with time zone, owned_by text)\n LANGUAGE plpython3u\n PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.openai\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.openai.DEFAULT_KEY_NAME, SD)\n    with ai.utils.VerboseRequestTrace(plpy, \"openai.list_models()\", verbose):\n        models = ai.openai.list_models(\n            plpy,\n            api_key_resolved,\n            ai.openai.str_arg_to_dict(client_config),\n            extra_headers,\n            extra_query)\n    for tup in models:\n        yield tup\n$function$\n",
      "description": null,
      "arguments": "api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb",
      "return_type": "TABLE(id text, created timestamp with time zone, owned_by text)",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 19128,
      "name": "openai_list_models_with_raw_response",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_list_models_with_raw_response(api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpython3u\n PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.openai\n    import ai.secrets\n    import ai.utils\n    from datetime import datetime, timezone\n\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.openai.DEFAULT_KEY_NAME, SD)\n    client = ai.openai.make_client(plpy, api_key, ai.openai.str_arg_to_dict(client_config))\n\n    kwargs = ai.openai.create_kwargs(\n        extra_headers=ai.openai.str_arg_to_dict(extra_headers),\n        extra_query=ai.openai.str_arg_to_dict(extra_query),\n    )\n\n    with ai.utils.VerboseRequestTrace(plpy, \"openai.list_models()\", verbose):\n        return client.models.with_raw_response.list(**kwargs).text\n$function$\n",
      "description": null,
      "arguments": "api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpython3u"
    },
    {
      "oid": 19140,
      "name": "openai_moderate",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_moderate(model text, input_text text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.openai\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.openai.DEFAULT_KEY_NAME, SD)\n    client = ai.openai.make_client(plpy, api_key_resolved, ai.openai.str_arg_to_dict(client_config))\n    kwargs = ai.openai.create_kwargs(\n        extra_headers=ai.openai.str_arg_to_dict(extra_headers),\n        extra_query=ai.openai.str_arg_to_dict(extra_query),\n        extra_body=ai.openai.str_arg_to_dict(extra_body))\n    with ai.utils.VerboseRequestTrace(plpy, \"openai.moderations.create()\", verbose):\n        moderation = client.moderations.create(\n            input=input_text,\n            model=model,\n            **kwargs)\n    return moderation.model_dump_json()\n$function$\n",
      "description": null,
      "arguments": "model text, input_text text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19141,
      "name": "openai_moderate_with_raw_response",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_moderate_with_raw_response(model text, input_text text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.openai\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.openai.DEFAULT_KEY_NAME, SD)\n    client = ai.openai.make_client(plpy, api_key_resolved, ai.openai.str_arg_to_dict(client_config))\n    kwargs = ai.openai.create_kwargs(\n        extra_headers=ai.openai.str_arg_to_dict(extra_headers),\n        extra_query=ai.openai.str_arg_to_dict(extra_query),\n        extra_body=ai.openai.str_arg_to_dict(extra_body))\n    with ai.utils.VerboseRequestTrace(plpy, \"openai.moderations.create()\", verbose):\n        moderation = client.moderations.with_raw_response.create(\n            input=input_text,\n            model=model,\n            **kwargs)\n    return moderation.text\n$function$\n",
      "description": null,
      "arguments": "model text, input_text text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, extra_headers jsonb DEFAULT NULL::jsonb, extra_query jsonb DEFAULT NULL::jsonb, extra_body jsonb DEFAULT NULL::jsonb, \"verbose\" boolean DEFAULT false, client_config jsonb DEFAULT NULL::jsonb",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19125,
      "name": "openai_tokenize",
      "definition": "CREATE OR REPLACE FUNCTION ai.openai_tokenize(model text, text_input text)\n RETURNS integer[]\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE STRICT\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import tiktoken\n    encoding = tiktoken.encoding_for_model(model)\n    tokens = encoding.encode(text_input)\n    return tokens\n$function$\n",
      "description": null,
      "arguments": "model text, text_input text",
      "return_type": "integer[]",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 18923,
      "name": "parsing_auto",
      "definition": "CREATE OR REPLACE FUNCTION ai.parsing_auto()\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_build_object\n    ( 'implementation', 'auto'\n    , 'config_type', 'parsing'\n    )\n$function$\n",
      "description": null,
      "arguments": "",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18926,
      "name": "parsing_docling",
      "definition": "CREATE OR REPLACE FUNCTION ai.parsing_docling()\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_build_object\n    ( 'implementation', 'docling'\n    , 'config_type', 'parsing'\n    )\n$function$\n",
      "description": null,
      "arguments": "",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18924,
      "name": "parsing_none",
      "definition": "CREATE OR REPLACE FUNCTION ai.parsing_none()\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_build_object\n    ( 'implementation', 'none'\n    , 'config_type', 'parsing'\n    )\n$function$\n",
      "description": null,
      "arguments": "",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18925,
      "name": "parsing_pymupdf",
      "definition": "CREATE OR REPLACE FUNCTION ai.parsing_pymupdf()\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_build_object\n    ( 'implementation', 'pymupdf'\n    , 'config_type', 'parsing'\n    )\n$function$\n",
      "description": null,
      "arguments": "",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18916,
      "name": "processing_default",
      "definition": "CREATE OR REPLACE FUNCTION ai.processing_default(batch_size integer DEFAULT NULL::integer, concurrency integer DEFAULT NULL::integer)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_strip_nulls(json_build_object\n    ( 'implementation', 'default'\n    , 'config_type', 'processing'\n    , 'batch_size', batch_size\n    , 'concurrency', concurrency\n    ))\n$function$\n",
      "description": null,
      "arguments": "batch_size integer DEFAULT NULL::integer, concurrency integer DEFAULT NULL::integer",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 19162,
      "name": "reveal_secret",
      "definition": "CREATE OR REPLACE FUNCTION ai.reveal_secret(secret_name text, use_cache boolean DEFAULT true)\n RETURNS text\n LANGUAGE plpython3u\n STABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.secrets\n    if use_cache:\n        return ai.secrets.reveal_secret(plpy, secret_name, SD)\n    else:\n        ai.secrets.remove_secret_from_cache(SD, secret_name)\n        return ai.secrets.reveal_secret(plpy, secret_name, None)\n$function$\n",
      "description": null,
      "arguments": "secret_name text, use_cache boolean DEFAULT true",
      "return_type": "text",
      "kind": "f",
      "kind_label": "function",
      "volatility": "s",
      "volatility_label": "stable",
      "language": "plpython3u"
    },
    {
      "oid": 19168,
      "name": "revoke_secret",
      "definition": "CREATE OR REPLACE FUNCTION ai.revoke_secret(secret_name text, revoke_from_role text)\n RETURNS void\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    delete from ai._secret_permissions\n    where \"name\" operator(pg_catalog.=) secret_name\n    and \"role\" operator(pg_catalog.=) revoke_from_role;\n$function$\n",
      "description": null,
      "arguments": "secret_name text, revoke_from_role text",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18975,
      "name": "sc_add_embedding",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_add_embedding(config jsonb, embedding_name name DEFAULT NULL::name, catalog_name name DEFAULT 'default'::name)\n RETURNS ai.semantic_catalog_embedding\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _config jsonb = sc_add_embedding.config;\n    _embedding_name name = sc_add_embedding.embedding_name;\n    _catalog_name name = sc_add_embedding.catalog_name;\n    _catalog_id int4;\n    _dims int4;\n    _tbl text;\n    _sql text;\n    _embedding ai.semantic_catalog_embedding;\nbegin\n    -- TODO: validate embedding config\n\n    _dims = (_config->'dimensions')::int4;\n    assert _dims is not null, 'embedding config is missing dimensions';\n    \n    -- grab the catalog id\n    select c.id into strict _catalog_id\n    from ai.semantic_catalog c\n    where c.catalog_name = _catalog_name\n    ;\n    \n    if _embedding_name is null then\n        select 'emb' ||\n        greatest\n        ( count(*)::int4\n        , max((regexp_match(e.embedding_name, '[0-9]+$'))[1]::int4)\n        ) + 1\n        into strict _embedding_name\n        from ai.semantic_catalog_embedding e\n        where e.semantic_catalog_id = _catalog_id\n        ;\n    end if;\n    \n    insert into ai.semantic_catalog_embedding (semantic_catalog_id, embedding_name, config)\n    values (_catalog_id, _embedding_name, _config)\n    returning * into strict _embedding\n    ;\n    \n    -- add the columns\n    foreach _tbl in array array['obj', 'sql', 'fact']\n    loop\n        _sql = format\n        (\n        $sql$\n            alter table ai.semantic_catalog_%s_%s add column %s public.vector(%s)\n        $sql$\n        , _tbl\n        , _catalog_id\n        , _embedding_name\n        , _dims\n        );\n        raise debug '%', _sql;\n        execute _sql;\n    end loop;\n    \n    perform ai._semantic_catalog_make_triggers(_catalog_id);\n    \n    return _embedding;\nend;\n$function$\n",
      "description": null,
      "arguments": "config jsonb, embedding_name name DEFAULT NULL::name, catalog_name name DEFAULT 'default'::name",
      "return_type": "ai.semantic_catalog_embedding",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 19002,
      "name": "sc_add_fact",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_add_fact(description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _catalog_name name = sc_add_fact.catalog_name;\n    _sql text;\n    _id int8;\nbegin\n    select format\n    ( $sql$\n        insert into ai.semantic_catalog_fact_%s\n        ( description\n        )\n        values\n        ( $1\n        )\n        returning id\n      $sql$\n    , x.id\n    ) into strict _sql\n    from ai.semantic_catalog x\n    where x.catalog_name = _catalog_name\n    ;\n    execute _sql using description\n    into strict _id;\n    return _id;\nend\n$function$\n",
      "description": null,
      "arguments": "description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 19000,
      "name": "sc_add_sql_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_add_sql_desc(sql text, description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _catalog_name name = sc_add_sql_desc.catalog_name;\n    _sql text;\n    _id int8;\nbegin\n    select format\n    ( $sql$\n        insert into ai.semantic_catalog_sql_%s\n        ( sql\n        , description\n        )\n        values\n        ( $1\n        , $2\n        )\n        returning id\n      $sql$\n    , x.id\n    ) into strict _sql\n    from ai.semantic_catalog x\n    where x.catalog_name = _catalog_name\n    ;\n    execute _sql using\n      sql\n    , description\n    into strict _id;\n    return _id;\nend\n$function$\n",
      "description": null,
      "arguments": "sql text, description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18976,
      "name": "sc_drop_embedding",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_drop_embedding(embedding_name name, catalog_name name DEFAULT 'default'::name)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _embedding_name name = sc_drop_embedding.embedding_name;\n    _catalog_name name = sc_drop_embedding.catalog_name;\n    _embedding ai.semantic_catalog_embedding;\n    _catalog_id int4;\n    _tbl text;\n    _sql text;\nbegin\n\n    select c.id into strict _catalog_id\n    from ai.semantic_catalog c\n    where c.catalog_name = _catalog_name\n    ;\n\n    delete from ai.semantic_catalog_embedding e\n    where e.semantic_catalog_id = _catalog_id\n    and e.embedding_name = _embedding_name\n    returning * into strict _embedding\n    ;\n    \n    -- drop the columns\n    foreach _tbl in array array['obj', 'sql', 'fact']\n    loop\n        _sql = format\n        (\n        $sql$\n            alter table ai.semantic_catalog_%s_%s drop column %s\n        $sql$\n        , _tbl\n        , _catalog_id\n        , _embedding_name\n        );\n        raise debug '%', _sql;\n        execute _sql;\n    end loop;\n    \n    perform ai._semantic_catalog_make_triggers(_catalog_id);\nend;\n$function$\n",
      "description": null,
      "arguments": "embedding_name name, catalog_name name DEFAULT 'default'::name",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18981,
      "name": "sc_grant_admin",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_grant_admin(role_name name)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _role_name name = sc_grant_admin.role_name;\n    _sql text;\nbegin\n\n    _sql = format($sql$grant usage on schema ai to %I$sql$, _role_name);\n    raise debug '%', _sql;\n    execute _sql;\n\n    for _sql in\n    (\n        select format(x, _role_name)\n        from unnest(array[\n            $sql$grant select, insert, update, delete, truncate on ai.semantic_catalog to %I$sql$,\n            $sql$grant usage, select, update on sequence ai.semantic_catalog_id_seq to %I$sql$,\n            $sql$grant select, insert, update, delete, truncate on ai.semantic_catalog_embedding to %I$sql$,\n            $sql$grant usage, select, update on sequence ai.semantic_catalog_embedding_id_seq to %I$sql$\n        ]) x\n    )\n    loop\n        raise debug '%', _sql;\n        execute _sql;\n    end loop;\n\n    for _sql in\n    (\n        select format(y, x.id, _role_name)\n        from ai.semantic_catalog x\n        cross join unnest(array[\n            $sql$grant select, insert, update, delete on ai.semantic_catalog_obj_%s to %I$sql$,\n            $sql$grant usage, select, update on sequence ai.semantic_catalog_obj_%s_id_seq to %I$sql$,\n            $sql$grant select, insert, update, delete on ai.semantic_catalog_sql_%s to %I$sql$,\n            $sql$grant usage, select, update on sequence ai.semantic_catalog_sql_%s_id_seq to %I$sql$,\n            $sql$grant select, insert, update, delete on ai.semantic_catalog_fact_%s to %I$sql$,\n            $sql$grant usage, select, update on sequence ai.semantic_catalog_fact_%s_id_seq to %I$sql$\n        ]) y\n    )\n    loop\n        raise debug '%', _sql;\n        execute _sql;\n    end loop;\nend\n$function$\n",
      "description": null,
      "arguments": "role_name name",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18983,
      "name": "sc_grant_obj_read",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_grant_obj_read(catalog_name name, role_name name)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n/*\n    grants select/execute on all database objects referenced in the specified catalog\n    grants usage on the schemas to which those objects belong\n*/\ndeclare\n    _catalog_name name = sc_grant_obj_read.catalog_name;\n    _role_name name = sc_grant_obj_read.role_name;\n    _catalog_id int;\n    _sql text;\nbegin\n    select x.id into strict _catalog_id\n    from ai.semantic_catalog x\n    where x.catalog_name = _catalog_name\n    ;\n    \n    if not has_table_privilege\n        ( _role_name\n        , format('ai.semantic_catalog_obj_%s', _catalog_id)\n        , 'select'\n        ) then\n        raise exception 'user must have access to the catalog first';\n    end if;\n\n    -- schemas\n    for _sql in\n    (\n        select format\n        ( $sql$grant usage on schema %I to %I$sql$\n        , x.schema_name\n        , _role_name\n        )\n        from\n        (\n            select distinct x.objnames[1] as schema_name\n            from ai._sc_obj(_catalog_id) x\n            where x.objsubid = 0\n        ) x\n    )\n    loop\n        raise debug '%', _sql;\n        execute _sql;\n    end loop;\n\n    -- objects\n    for _sql in\n    (\n        select format\n        ( $sql$grant %s on %s %I.%I%s to %I$sql$\n        , case when x.objtype in ('aggregate', 'function', 'procedure')\n            then 'execute'\n            else 'select'\n          end\n        , case\n            when x.objtype in ('function', 'aggregate') then 'function'\n            else x.objtype\n          end\n        , x.objnames[1]\n        , x.objnames[2]\n        , case when x.objtype in ('aggregate', 'function', 'procedure')\n            then format('(%s)', array_to_string(x.objargs, ', '))\n            else ''\n          end\n        , _role_name\n        )\n        from ai._sc_obj(_catalog_id) x\n        where x.objsubid = 0\n        order by x.objnames\n    )\n    loop\n        raise debug '%', _sql;\n        execute _sql;\n    end loop;\nend\n$function$\n",
      "description": null,
      "arguments": "catalog_name name, role_name name",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18979,
      "name": "sc_grant_read",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_grant_read(catalog_name name, role_name name)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _catalog_name name = sc_grant_read.catalog_name;\n    _role_name name = sc_grant_read.role_name;\n    _catalog_id int;\n    _sql text;\nbegin\n    select x.id into strict _catalog_id\n    from ai.semantic_catalog x\n    where x.catalog_name = _catalog_name\n    ;\n\n    _sql = format($sql$grant usage on schema ai to %I$sql$, _role_name);\n    raise debug '%', _sql;\n    execute _sql;\n\n    for _sql in\n    (\n        select format(x, _role_name)\n        from unnest(array[\n            $sql$grant select on ai.semantic_catalog to %I$sql$,\n            $sql$grant select on ai.semantic_catalog_embedding to %I$sql$\n        ]) x\n    )\n    loop\n        raise debug '%', _sql;\n        execute _sql;\n    end loop;\n\n    for _sql in\n    (\n        select format(y, x.id, _role_name)\n        from ai.semantic_catalog x\n        cross join unnest(array[\n            $sql$grant select on ai.semantic_catalog_obj_%s to %I$sql$,\n            $sql$grant select on ai.semantic_catalog_sql_%s to %I$sql$,\n            $sql$grant select on ai.semantic_catalog_fact_%s to %I$sql$\n        ]) y\n        where x.catalog_name = _catalog_name\n    )\n    loop\n        raise debug '%', _sql;\n        execute _sql;\n    end loop;\nend\n$function$\n",
      "description": null,
      "arguments": "catalog_name name, role_name name",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18980,
      "name": "sc_grant_write",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_grant_write(catalog_name name, role_name name)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _catalog_name name = sc_grant_write.catalog_name;\n    _role_name name = sc_grant_write.role_name;\n    _catalog_id int;\n    _sql text;\nbegin\n    select x.id into strict _catalog_id\n    from ai.semantic_catalog x\n    where x.catalog_name = _catalog_name\n    ;\n\n    _sql = format($sql$grant usage on schema ai to %I$sql$, _role_name);\n    raise debug '%', _sql;\n    execute _sql;\n\n    for _sql in\n    (\n        select format(x, _role_name)\n        from unnest(array[\n            $sql$grant select on ai.semantic_catalog to %I$sql$,\n            $sql$grant select on ai.semantic_catalog_embedding to %I$sql$\n        ]) x\n    )\n    loop\n        raise debug '%', _sql;\n        execute _sql;\n    end loop;\n\n    for _sql in\n    (\n        select format(y, x.id, _role_name)\n        from ai.semantic_catalog x\n        cross join unnest(array[\n            $sql$grant select, insert, update, delete on ai.semantic_catalog_obj_%s to %I$sql$,\n            $sql$grant usage, select, update on sequence ai.semantic_catalog_obj_%s_id_seq to %I$sql$,\n            $sql$grant select, insert, update, delete on ai.semantic_catalog_sql_%s to %I$sql$,\n            $sql$grant usage, select, update on sequence ai.semantic_catalog_sql_%s_id_seq to %I$sql$,\n            $sql$grant select, insert, update, delete on ai.semantic_catalog_fact_%s to %I$sql$,\n            $sql$grant usage, select, update on sequence ai.semantic_catalog_fact_%s_id_seq to %I$sql$\n        ]) y\n        where x.catalog_name = _catalog_name\n    )\n    loop\n        raise debug '%', _sql;\n        execute _sql;\n    end loop;\nend\n$function$\n",
      "description": null,
      "arguments": "catalog_name name, role_name name",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18991,
      "name": "sc_set_agg_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_agg_desc(classid oid, objid oid, schema_name name, agg_name name, objargs text[], description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select *\n    from ai.sc_set_obj_desc\n    ( classid\n    , objid\n    , 0\n    , 'aggregate'\n    , array[schema_name, agg_name]\n    , coalesce(objargs, array[]::text[])\n    , description\n    , catalog_name\n    );\n$function$\n",
      "description": null,
      "arguments": "classid oid, objid oid, schema_name name, agg_name name, objargs text[], description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18999,
      "name": "sc_set_agg_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_agg_desc(a regprocedure, description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select ai.sc_set_obj_desc\n    ( 'pg_catalog.pg_proc'::regclass::oid\n    , a\n    , 0\n    , x.type\n    , x.object_names\n    , x.object_args\n    , description\n    , catalog_name\n    )\n    from pg_proc o\n    cross join pg_identify_object_as_address\n    ( 'pg_catalog.pg_proc'::regclass::oid\n    , a\n    , 0\n    ) x\n    where o.oid = a\n    and o.prokind = 'a'\n    ;\n$function$\n",
      "description": null,
      "arguments": "a regprocedure, description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18990,
      "name": "sc_set_func_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_func_desc(classid oid, objid oid, schema_name name, func_name name, objargs text[], description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select *\n    from ai.sc_set_obj_desc\n    ( classid\n    , objid\n    , 0\n    , 'function'\n    , array[schema_name, func_name]\n    , coalesce(objargs, array[]::text[])\n    , description\n    , catalog_name\n    );\n$function$\n",
      "description": null,
      "arguments": "classid oid, objid oid, schema_name name, func_name name, objargs text[], description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18998,
      "name": "sc_set_func_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_func_desc(f regprocedure, description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select ai.sc_set_obj_desc\n    ( 'pg_catalog.pg_proc'::regclass::oid\n    , f\n    , 0\n    , x.type\n    , x.object_names\n    , x.object_args\n    , description\n    , catalog_name\n    )\n    from pg_proc o\n    cross join pg_identify_object_as_address\n    ( 'pg_catalog.pg_proc'::regclass::oid\n    , f\n    , 0\n    ) x\n    where o.oid = f\n    and o.prokind in ('f', 'w')\n    ;\n$function$\n",
      "description": null,
      "arguments": "f regprocedure, description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18984,
      "name": "sc_set_obj_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_obj_desc(classid oid, objid oid, objsubid integer, objtype text, objnames text[], objargs text[], description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _catalog_name name = sc_set_obj_desc.catalog_name;\n    _sql text;\n    _id int8;\nbegin\n    select format\n    ( $sql$\n        merge into ai.semantic_catalog_obj_%s tgt\n        using\n        (\n            select\n              $1 as classid\n            , $2 as objid\n            , $3 as objsubid\n            , $4 as objtype\n            , $5 as objnames\n            , $6 as objargs\n            , $7 as description\n        ) src\n        on (tgt.classid = src.classid and tgt.objid = src.objid and tgt.objsubid = src.objsubid)\n        when matched then update set description = src.description\n        when not matched by target then\n        insert\n        ( classid\n        , objid\n        , objsubid\n        , objtype\n        , objnames\n        , objargs\n        , description\n        )\n        values\n        ( src.classid\n        , src.objid\n        , src.objsubid\n        , src.objtype\n        , src.objnames\n        , src.objargs\n        , src.description\n        )\n        returning id\n      $sql$\n    , x.id\n    ) into strict _sql\n    from ai.semantic_catalog x\n    where x.catalog_name = _catalog_name\n    ;\n    execute _sql using\n      classid\n    , objid\n    , objsubid\n    , objtype\n    , objnames\n    , objargs\n    , description\n    into strict _id;\n    return _id;\nend\n$function$\n",
      "description": null,
      "arguments": "classid oid, objid oid, objsubid integer, objtype text, objnames text[], objargs text[], description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18992,
      "name": "sc_set_obj_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_obj_desc(objtype text, objnames text[], objargs text[], description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _classid oid;\n    _objid oid;\n    _objsubid integer;\nbegin\n    select\n      x.classid\n    , x.objid\n    , x.subobjid\n    into strict\n      _classid\n    , _objid\n    , _objsubid\n    from pg_get_object_address(objtype, objnames, objargs) x\n    ;\n    return ai.sc_set_obj_desc\n    ( _classid\n    , _objid\n    , _objsubid\n    , objtype\n    , objnames\n    , objargs\n    , description\n    , catalog_name\n    );\nend\n$function$\n",
      "description": null,
      "arguments": "objtype text, objnames text[], objargs text[], description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18989,
      "name": "sc_set_proc_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_proc_desc(classid oid, objid oid, schema_name name, proc_name name, objargs text[], description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select *\n    from ai.sc_set_obj_desc\n    ( classid\n    , objid\n    , 0\n    , 'procedure'\n    , array[schema_name, proc_name]\n    , coalesce(objargs, array[]::text[])\n    , description\n    , catalog_name\n    );\n$function$\n",
      "description": null,
      "arguments": "classid oid, objid oid, schema_name name, proc_name name, objargs text[], description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18997,
      "name": "sc_set_proc_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_proc_desc(p regprocedure, description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select ai.sc_set_obj_desc\n    ( 'pg_catalog.pg_proc'::regclass::oid\n    , p\n    , 0\n    , x.type\n    , x.object_names\n    , x.object_args\n    , description\n    , catalog_name\n    )\n    from pg_proc o\n    cross join pg_identify_object_as_address\n    ( 'pg_catalog.pg_proc'::regclass::oid\n    , p\n    , 0\n    ) x\n    where o.oid = p\n    and o.prokind = 'p'\n    ;\n$function$\n",
      "description": null,
      "arguments": "p regprocedure, description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18986,
      "name": "sc_set_table_col_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_table_col_desc(classid oid, objid oid, objsubid integer, schema_name name, table_name name, column_name name, description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select *\n    from ai.sc_set_obj_desc\n    ( classid\n    , objid\n    , objsubid\n    , 'table column'\n    , array[schema_name, table_name, column_name]\n    , array[]::text[]\n    , description\n    , catalog_name\n    );\n$function$\n",
      "description": null,
      "arguments": "classid oid, objid oid, objsubid integer, schema_name name, table_name name, column_name name, description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18994,
      "name": "sc_set_table_col_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_table_col_desc(t regclass, column_name name, description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select ai.sc_set_obj_desc\n    ( 'pg_catalog.pg_class'::regclass::oid\n    , t\n    , a.attnum\n    , x.type\n    , x.object_names\n    , x.object_args\n    , description\n    , catalog_name\n    )\n    from pg_class k\n    inner join pg_attribute a on (k.oid = a.attrelid)\n    cross join lateral pg_identify_object_as_address\n    ( 'pg_catalog.pg_class'::regclass::oid\n    , t\n    , a.attnum\n    ) x\n    where k.oid = t\n    and k.relkind in ('r', 'p', 'f')\n    and a.attname = column_name\n    ;\n$function$\n",
      "description": null,
      "arguments": "t regclass, column_name name, description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18985,
      "name": "sc_set_table_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_table_desc(classid oid, objid oid, schema_name name, table_name name, description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select *\n    from ai.sc_set_obj_desc\n    ( classid\n    , objid\n    , 0\n    , 'table'\n    , array[schema_name, table_name]\n    , array[]::text[]\n    , description\n    , catalog_name\n    );\n$function$\n",
      "description": null,
      "arguments": "classid oid, objid oid, schema_name name, table_name name, description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18993,
      "name": "sc_set_table_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_table_desc(t regclass, description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select ai.sc_set_obj_desc\n    ( 'pg_catalog.pg_class'::regclass::oid\n    , t\n    , 0\n    , x.type\n    , x.object_names\n    , x.object_args\n    , description\n    , catalog_name\n    )\n    from pg_class k\n    cross join pg_identify_object_as_address\n    ( 'pg_catalog.pg_class'::regclass::oid\n    , t\n    , 0\n    ) x\n    where k.oid = t\n    and k.relkind in ('r', 'p', 'f')\n    ;\n$function$\n",
      "description": null,
      "arguments": "t regclass, description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18988,
      "name": "sc_set_view_col_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_view_col_desc(classid oid, objid oid, objsubid integer, schema_name name, view_name name, column_name name, description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select *\n    from ai.sc_set_obj_desc\n    ( classid\n    , objid\n    , objsubid\n    , 'view column'\n    , array[schema_name, view_name, column_name]\n    , array[]::text[]\n    , description\n    , catalog_name\n    );\n$function$\n",
      "description": null,
      "arguments": "classid oid, objid oid, objsubid integer, schema_name name, view_name name, column_name name, description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18996,
      "name": "sc_set_view_col_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_view_col_desc(v regclass, column_name name, description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select ai.sc_set_obj_desc\n    ( 'pg_catalog.pg_class'::regclass::oid\n    , v\n    , a.attnum\n    , x.type\n    , x.object_names\n    , x.object_args\n    , description\n    , catalog_name\n    )\n    from pg_class k\n    inner join pg_attribute a on (k.oid = a.attrelid)\n    cross join lateral pg_identify_object_as_address\n    ( 'pg_catalog.pg_class'::regclass::oid\n    , v\n    , a.attnum\n    ) x\n    where k.oid = v\n    and k.relkind in ('v', 'm')\n    and a.attname = column_name\n    ;\n$function$\n",
      "description": null,
      "arguments": "v regclass, column_name name, description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18987,
      "name": "sc_set_view_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_view_desc(classid oid, objid oid, schema_name name, view_name name, description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select *\n    from ai.sc_set_obj_desc\n    ( classid\n    , objid\n    , 0\n    , 'view'\n    , array[schema_name, view_name]\n    , array[]::text[]\n    , description\n    , catalog_name\n    );\n$function$\n",
      "description": null,
      "arguments": "classid oid, objid oid, schema_name name, view_name name, description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 18995,
      "name": "sc_set_view_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_set_view_desc(v regclass, description text, catalog_name name DEFAULT 'default'::name)\n RETURNS bigint\n LANGUAGE sql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select ai.sc_set_obj_desc\n    ( 'pg_catalog.pg_class'::regclass::oid\n    , v\n    , 0\n    , x.type\n    , x.object_names\n    , x.object_args\n    , description\n    , catalog_name\n    )\n    from pg_class k\n    cross join pg_identify_object_as_address\n    ( 'pg_catalog.pg_class'::regclass::oid\n    , v\n    , 0\n    ) x\n    where k.oid = v\n    and k.relkind in ('v', 'm')\n    ;\n$function$\n",
      "description": null,
      "arguments": "v regclass, description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "sql"
    },
    {
      "oid": 19003,
      "name": "sc_update_fact",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_update_fact(id bigint, description text, catalog_name name DEFAULT 'default'::name)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _catalog_name name = sc_update_fact.catalog_name;\n    _sql text;\nbegin\n    select format\n    ( $sql$\n        update ai.semantic_catalog_fact_%s set description = $1\n        where id = $2\n      $sql$\n    , x.id\n    ) into strict _sql\n    from ai.semantic_catalog x\n    where x.catalog_name = _catalog_name\n    ;\n    execute _sql using description, id;\nend\n$function$\n",
      "description": null,
      "arguments": "id bigint, description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 19001,
      "name": "sc_update_sql_desc",
      "definition": "CREATE OR REPLACE FUNCTION ai.sc_update_sql_desc(id bigint, sql text, description text, catalog_name name DEFAULT 'default'::name)\n RETURNS void\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _catalog_name name = sc_update_sql_desc.catalog_name;\n    _sql text;\nbegin\n    select format\n    ( $sql$\n        update ai.semantic_catalog_sql_%s set\n          sql = $1\n        , description = $2\n        where id = $3\n      $sql$\n    , x.id\n    ) into strict _sql\n    from ai.semantic_catalog x\n    where x.catalog_name = _catalog_name\n    ;\n    execute _sql using\n      sql\n    , description\n    , id\n    ;\nend\n$function$\n",
      "description": null,
      "arguments": "id bigint, sql text, description text, catalog_name name DEFAULT 'default'::name",
      "return_type": "void",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18899,
      "name": "scheduling_default",
      "definition": "CREATE OR REPLACE FUNCTION ai.scheduling_default()\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select pg_catalog.jsonb_build_object\n    ( 'implementation', 'default'\n    , 'config_type', 'scheduling'\n    )\n$function$\n",
      "description": null,
      "arguments": "",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18898,
      "name": "scheduling_none",
      "definition": "CREATE OR REPLACE FUNCTION ai.scheduling_none()\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select pg_catalog.jsonb_build_object\n    ( 'implementation', 'none'\n    , 'config_type', 'scheduling'\n    )\n$function$\n",
      "description": null,
      "arguments": "",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18900,
      "name": "scheduling_timescaledb",
      "definition": "CREATE OR REPLACE FUNCTION ai.scheduling_timescaledb(schedule_interval interval DEFAULT '00:05:00'::interval, initial_start timestamp with time zone DEFAULT NULL::timestamp with time zone, fixed_schedule boolean DEFAULT NULL::boolean, timezone text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select json_strip_nulls(json_build_object\n    ( 'implementation', 'timescaledb'\n    , 'config_type', 'scheduling'\n    , 'schedule_interval', schedule_interval\n    , 'initial_start', initial_start\n    , 'fixed_schedule', fixed_schedule\n    , 'timezone', timezone\n    ))\n$function$\n",
      "description": null,
      "arguments": "schedule_interval interval DEFAULT '00:05:00'::interval, initial_start timestamp with time zone DEFAULT NULL::timestamp with time zone, fixed_schedule boolean DEFAULT NULL::boolean, timezone text DEFAULT NULL::text",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "sql"
    },
    {
      "oid": 18969,
      "name": "set_scheduling",
      "definition": "CREATE OR REPLACE FUNCTION ai.set_scheduling(vectorizer_id integer, scheduling jsonb DEFAULT ai.scheduling_default(), indexing jsonb DEFAULT ai.indexing_default())\n RETURNS jsonb\n LANGUAGE plpgsql\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n  _job_id pg_catalog.int8;\n  _updated_config pg_catalog.jsonb;\nbegin\n    -- if ai.indexing_default, resolve the default\n    if indexing operator(pg_catalog.->>) 'implementation' = 'default' then\n        indexing = ai._resolve_indexing_default();\n    end if;\n\n    -- validate the indexing config\n    perform ai._validate_indexing(indexing);\n\n    -- if ai.scheduling_default, resolve the default\n    if scheduling operator(pg_catalog.->>) 'implementation' = 'default' then\n        scheduling = ai._resolve_scheduling_default();\n    end if;\n\n    -- validate the scheduling config\n    perform ai._validate_scheduling(scheduling);\n\n    -- if scheduling is none then indexing must also be none\n    if scheduling operator(pg_catalog.->>) 'implementation' = 'none'\n    and indexing operator(pg_catalog.->>) 'implementation' != 'none' then\n        raise exception 'automatic indexing is not supported without scheduling. set indexing=>ai.indexing_none() when scheduling=>ai.scheduling_none()';\n    end if;\n\n    -- delete current job if it exists\n    PERFORM public.delete_job(job_id::pg_catalog.int4)\n    FROM (\n        SELECT config #>> '{scheduling,job_id}' as job_id\n        FROM ai.vectorizer\n        WHERE id = vectorizer_id\n    ) c\n    WHERE job_id IS NOT NULL;\n\n    -- schedule the async ext job\n    select ai._vectorizer_schedule_job\n    ( vectorizer_id\n    , scheduling\n    ) into _job_id\n    ;\n    if _job_id is not null then\n        scheduling = pg_catalog.jsonb_insert(scheduling, array['job_id'], pg_catalog.to_jsonb(_job_id));\n    end if;\n\n    UPDATE ai.vectorizer\n    SET config = config operator(pg_catalog.||) pg_catalog.jsonb_build_object\n    ( 'scheduling'\n    , scheduling\n    , 'indexing'\n    , indexing\n    )\n    WHERE id = vectorizer_id\n    RETURNING config INTO _updated_config;\n\n    RETURN _updated_config;\nend\n$function$\n",
      "description": null,
      "arguments": "vectorizer_id integer, scheduling jsonb DEFAULT ai.scheduling_default(), indexing jsonb DEFAULT ai.indexing_default()",
      "return_type": "jsonb",
      "kind": "f",
      "kind_label": "function",
      "volatility": "v",
      "volatility_label": "volatile",
      "language": "plpgsql"
    },
    {
      "oid": 18966,
      "name": "vectorizer_embed",
      "definition": "CREATE OR REPLACE FUNCTION ai.vectorizer_embed(embedding_config jsonb, input_text text, input_type text DEFAULT NULL::text)\n RETURNS vector\n LANGUAGE plpgsql\n IMMUTABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _emb public.vector;\nbegin\n    case embedding_config operator(pg_catalog.->>) 'implementation'\n        when 'openai' then\n            _emb = ai.openai_embed\n            ( embedding_config operator(pg_catalog.->>) 'model'\n            , input_text\n            , api_key_name=>(embedding_config operator(pg_catalog.->>) 'api_key_name')\n            , dimensions=>(embedding_config operator(pg_catalog.->>) 'dimensions')::pg_catalog.int4\n            , openai_user=>(embedding_config operator(pg_catalog.->>) 'user')\n            );\n        when 'ollama' then\n            _emb = ai.ollama_embed\n            ( embedding_config operator(pg_catalog.->>) 'model'\n            , input_text\n            , host=>(embedding_config operator(pg_catalog.->>) 'base_url')\n            , keep_alive=>(embedding_config operator(pg_catalog.->>) 'keep_alive')\n            , embedding_options=>(embedding_config operator(pg_catalog.->) 'options')\n            );\n        when 'voyageai' then\n            _emb = ai.voyageai_embed\n            ( embedding_config operator(pg_catalog.->>) 'model'\n            , input_text\n            , input_type=>coalesce(input_type, 'query')\n            , api_key_name=>(embedding_config operator(pg_catalog.->>) 'api_key_name')\n            );\n        else\n            raise exception 'unsupported embedding implementation';\n    end case;\n\n    return _emb;\nend\n$function$\n",
      "description": null,
      "arguments": "embedding_config jsonb, input_text text, input_type text DEFAULT NULL::text",
      "return_type": "vector",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpgsql"
    },
    {
      "oid": 18967,
      "name": "vectorizer_embed",
      "definition": "CREATE OR REPLACE FUNCTION ai.vectorizer_embed(vectorizer_id integer, input_text text, input_type text DEFAULT NULL::text)\n RETURNS vector\n LANGUAGE sql\n STABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select ai.vectorizer_embed\n    ( v.config operator(pg_catalog.->) 'embedding'\n    , input_text\n    , input_type\n    )\n    from ai.vectorizer v\n    where v.id operator(pg_catalog.=) vectorizer_id\n    ;\n$function$\n",
      "description": null,
      "arguments": "vectorizer_id integer, input_text text, input_type text DEFAULT NULL::text",
      "return_type": "vector",
      "kind": "f",
      "kind_label": "function",
      "volatility": "s",
      "volatility_label": "stable",
      "language": "sql"
    },
    {
      "oid": 18968,
      "name": "vectorizer_embed",
      "definition": "CREATE OR REPLACE FUNCTION ai.vectorizer_embed(name text, input_text text, input_type text DEFAULT NULL::text)\n RETURNS vector\n LANGUAGE sql\n STABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    select ai.vectorizer_embed(v.id, input_text, input_type)\n    from ai.vectorizer v\n    where v.name operator(pg_catalog.=) vectorizer_embed.name\n    ;\n$function$\n",
      "description": null,
      "arguments": "name text, input_text text, input_type text DEFAULT NULL::text",
      "return_type": "vector",
      "kind": "f",
      "kind_label": "function",
      "volatility": "s",
      "volatility_label": "stable",
      "language": "sql"
    },
    {
      "oid": 18959,
      "name": "vectorizer_queue_pending",
      "definition": "CREATE OR REPLACE FUNCTION ai.vectorizer_queue_pending(vectorizer_id integer, exact_count boolean DEFAULT false)\n RETURNS bigint\n LANGUAGE plpgsql\n STABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\ndeclare\n    _queue_schema pg_catalog.name;\n    _queue_table pg_catalog.name;\n    _sql pg_catalog.text;\n    _queue_depth pg_catalog.int8;\nbegin\n    select v.queue_schema, v.queue_table into _queue_schema, _queue_table\n    from ai.vectorizer v\n    where v.id operator(pg_catalog.=) vectorizer_id\n    ;\n\n    if _queue_schema is null or _queue_table is null then\n        raise exception 'vectorizer has no queue table';\n    end if;\n\n    if exact_count then\n        select format\n        ( $sql$select count(1) from %I.%I$sql$\n        , _queue_schema, _queue_table\n        ) into strict _sql\n        ;\n        execute _sql into strict _queue_depth;\n    else\n        select format\n        ( $sql$select count(*) from (select 1 from %I.%I limit 10001) as subselect$sql$\n        , _queue_schema, _queue_table\n        ) into strict _sql\n        ;\n        execute _sql into strict _queue_depth;\n        if _queue_depth operator(pg_catalog.=) 10001 then\n            _queue_depth = 9223372036854775807; -- max bigint value\n        end if;\n    end if;\n\n    return _queue_depth;\nend;\n$function$\n",
      "description": null,
      "arguments": "vectorizer_id integer, exact_count boolean DEFAULT false",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "s",
      "volatility_label": "stable",
      "language": "plpgsql"
    },
    {
      "oid": 18960,
      "name": "vectorizer_queue_pending",
      "definition": "CREATE OR REPLACE FUNCTION ai.vectorizer_queue_pending(name text, exact_count boolean DEFAULT false)\n RETURNS bigint\n LANGUAGE sql\n STABLE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n   select ai.vectorizer_queue_pending(v.id, exact_count)\n   from ai.vectorizer v\n   where v.name operator(pg_catalog.=) vectorizer_queue_pending.name;\n$function$\n",
      "description": null,
      "arguments": "name text, exact_count boolean DEFAULT false",
      "return_type": "bigint",
      "kind": "f",
      "kind_label": "function",
      "volatility": "s",
      "volatility_label": "stable",
      "language": "sql"
    },
    {
      "oid": 19169,
      "name": "voyageai_embed",
      "definition": "CREATE OR REPLACE FUNCTION ai.voyageai_embed(model text, input_text text, input_type text DEFAULT NULL::text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false)\n RETURNS vector\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.voyageai\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.voyageai.DEFAULT_KEY_NAME, SD)\n    with ai.utils.VerboseRequestTrace(plpy, \"voyageai.embed()\", verbose):\n        args = {}\n        if input_type is not None:\n            args[\"input_type\"] = input_type\n    for tup in ai.voyageai.embed(model, [input_text], api_key=api_key_resolved, **args):\n        return tup[1]\n$function$\n",
      "description": null,
      "arguments": "model text, input_text text, input_type text DEFAULT NULL::text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false",
      "return_type": "vector",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    },
    {
      "oid": 19170,
      "name": "voyageai_embed",
      "definition": "CREATE OR REPLACE FUNCTION ai.voyageai_embed(model text, input_texts text[], input_type text DEFAULT NULL::text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false)\n RETURNS TABLE(index integer, embedding vector)\n LANGUAGE plpython3u\n IMMUTABLE PARALLEL SAFE\n SET search_path TO 'pg_catalog', 'pg_temp'\nAS $function$\n    if \"ai.version\" not in GD:\n        r = plpy.execute(\"select coalesce(pg_catalog.current_setting('ai.python_lib_dir', true), '/usr/local/lib/pgai') as python_lib_dir\")\n        python_lib_dir = r[0][\"python_lib_dir\"]\n        from pathlib import Path\n        import sys\n        import sysconfig\n        # Note: we remove system-level python packages from the path to avoid\n        # them being loaded and taking precedence over our dependencies.\n        # This seems paranoid, but it was a real problem.\n        if \"purelib\" in sysconfig.get_path_names() and sysconfig.get_path(\"purelib\") in sys.path:\n            sys.path.remove(sysconfig.get_path(\"purelib\"))\n        # Debian based systems have their own convention and install some\n        # packages in a dist-packages directory.\n        system_paths_to_remove = [\n            '/usr/lib/python3/dist-packages',\n        ]\n        for path in system_paths_to_remove:\n            if path in sys.path:\n                sys.path.remove(path)\n        python_lib_dir = Path(python_lib_dir).joinpath(\"0.11.2\")\n        import site\n        site.addsitedir(str(python_lib_dir))\n        from ai import __version__ as ai_version\n        assert(\"0.11.2\" == ai_version)\n        GD[\"ai.version\"] = \"0.11.2\"\n    else:\n        if GD[\"ai.version\"] != \"0.11.2\":\n            plpy.fatal(\"the pgai extension version has changed. start a new session\")\n    import ai.voyageai\n    import ai.secrets\n    import ai.utils\n    api_key_resolved = ai.secrets.get_secret(plpy, api_key, api_key_name, ai.voyageai.DEFAULT_KEY_NAME, SD)\n    args = {}\n    if input_type is not None:\n        args[\"input_type\"] = input_type\n    \n    with ai.utils.VerboseRequestTrace(plpy, \"voyageai.embed()\", verbose):\n        results = ai.voyageai.embed(model, input_texts, api_key=api_key_resolved, **args) \n        \n    for tup in results:\n        yield tup\n$function$\n",
      "description": null,
      "arguments": "model text, input_texts text[], input_type text DEFAULT NULL::text, api_key text DEFAULT NULL::text, api_key_name text DEFAULT NULL::text, \"verbose\" boolean DEFAULT false",
      "return_type": "TABLE(index integer, embedding vector)",
      "kind": "f",
      "kind_label": "function",
      "volatility": "i",
      "volatility_label": "immutable",
      "language": "plpython3u"
    }
  ],
  "triggers": [],
  "types": [
    {
      "oid": 19117,
      "name": "__secret_permissions",
      "formatted_type": "ai._secret_permissions[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 18813,
      "name": "__vectorizer_errors",
      "formatted_type": "ai._vectorizer_errors[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 19033,
      "name": "__vectorizer_q_1",
      "formatted_type": "ai._vectorizer_q_1[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1974279,
      "name": "__vectorizer_q_132",
      "formatted_type": "ai._vectorizer_q_132[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1974310,
      "name": "__vectorizer_q_133",
      "formatted_type": "ai._vectorizer_q_133[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1974341,
      "name": "__vectorizer_q_134",
      "formatted_type": "ai._vectorizer_q_134[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1974372,
      "name": "__vectorizer_q_135",
      "formatted_type": "ai._vectorizer_q_135[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1974403,
      "name": "__vectorizer_q_136",
      "formatted_type": "ai._vectorizer_q_136[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1974434,
      "name": "__vectorizer_q_137",
      "formatted_type": "ai._vectorizer_q_137[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 19078,
      "name": "__vectorizer_q_2",
      "formatted_type": "ai._vectorizer_q_2[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 20800,
      "name": "__vectorizer_q_48",
      "formatted_type": "ai._vectorizer_q_48[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 20831,
      "name": "__vectorizer_q_49",
      "formatted_type": "ai._vectorizer_q_49[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 20862,
      "name": "__vectorizer_q_50",
      "formatted_type": "ai._vectorizer_q_50[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 20893,
      "name": "__vectorizer_q_51",
      "formatted_type": "ai._vectorizer_q_51[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 20924,
      "name": "__vectorizer_q_52",
      "formatted_type": "ai._vectorizer_q_52[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 20955,
      "name": "__vectorizer_q_53",
      "formatted_type": "ai._vectorizer_q_53[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 20986,
      "name": "__vectorizer_q_54",
      "formatted_type": "ai._vectorizer_q_54[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 21017,
      "name": "__vectorizer_q_55",
      "formatted_type": "ai._vectorizer_q_55[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 21048,
      "name": "__vectorizer_q_56",
      "formatted_type": "ai._vectorizer_q_56[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1887358,
      "name": "__vectorizer_q_58",
      "formatted_type": "ai._vectorizer_q_58[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1887389,
      "name": "__vectorizer_q_59",
      "formatted_type": "ai._vectorizer_q_59[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1887420,
      "name": "__vectorizer_q_60",
      "formatted_type": "ai._vectorizer_q_60[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1887451,
      "name": "__vectorizer_q_61",
      "formatted_type": "ai._vectorizer_q_61[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1887482,
      "name": "__vectorizer_q_62",
      "formatted_type": "ai._vectorizer_q_62[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1887513,
      "name": "__vectorizer_q_63",
      "formatted_type": "ai._vectorizer_q_63[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1887544,
      "name": "__vectorizer_q_71",
      "formatted_type": "ai._vectorizer_q_71[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965425,
      "name": "__vectorizer_q_72",
      "formatted_type": "ai._vectorizer_q_72[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965456,
      "name": "__vectorizer_q_73",
      "formatted_type": "ai._vectorizer_q_73[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965487,
      "name": "__vectorizer_q_74",
      "formatted_type": "ai._vectorizer_q_74[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965518,
      "name": "__vectorizer_q_75",
      "formatted_type": "ai._vectorizer_q_75[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965549,
      "name": "__vectorizer_q_76",
      "formatted_type": "ai._vectorizer_q_76[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965580,
      "name": "__vectorizer_q_77",
      "formatted_type": "ai._vectorizer_q_77[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965611,
      "name": "__vectorizer_q_78",
      "formatted_type": "ai._vectorizer_q_78[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965642,
      "name": "__vectorizer_q_79",
      "formatted_type": "ai._vectorizer_q_79[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965673,
      "name": "__vectorizer_q_80",
      "formatted_type": "ai._vectorizer_q_80[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965704,
      "name": "__vectorizer_q_81",
      "formatted_type": "ai._vectorizer_q_81[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965735,
      "name": "__vectorizer_q_82",
      "formatted_type": "ai._vectorizer_q_82[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965766,
      "name": "__vectorizer_q_83",
      "formatted_type": "ai._vectorizer_q_83[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965797,
      "name": "__vectorizer_q_84",
      "formatted_type": "ai._vectorizer_q_84[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965828,
      "name": "__vectorizer_q_85",
      "formatted_type": "ai._vectorizer_q_85[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965859,
      "name": "__vectorizer_q_86",
      "formatted_type": "ai._vectorizer_q_86[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 19039,
      "name": "__vectorizer_q_failed_1",
      "formatted_type": "ai._vectorizer_q_failed_1[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1974285,
      "name": "__vectorizer_q_failed_132",
      "formatted_type": "ai._vectorizer_q_failed_132[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1974316,
      "name": "__vectorizer_q_failed_133",
      "formatted_type": "ai._vectorizer_q_failed_133[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1974347,
      "name": "__vectorizer_q_failed_134",
      "formatted_type": "ai._vectorizer_q_failed_134[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1974378,
      "name": "__vectorizer_q_failed_135",
      "formatted_type": "ai._vectorizer_q_failed_135[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1974409,
      "name": "__vectorizer_q_failed_136",
      "formatted_type": "ai._vectorizer_q_failed_136[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1974440,
      "name": "__vectorizer_q_failed_137",
      "formatted_type": "ai._vectorizer_q_failed_137[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 19084,
      "name": "__vectorizer_q_failed_2",
      "formatted_type": "ai._vectorizer_q_failed_2[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 20806,
      "name": "__vectorizer_q_failed_48",
      "formatted_type": "ai._vectorizer_q_failed_48[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 20837,
      "name": "__vectorizer_q_failed_49",
      "formatted_type": "ai._vectorizer_q_failed_49[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 20868,
      "name": "__vectorizer_q_failed_50",
      "formatted_type": "ai._vectorizer_q_failed_50[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 20899,
      "name": "__vectorizer_q_failed_51",
      "formatted_type": "ai._vectorizer_q_failed_51[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 20930,
      "name": "__vectorizer_q_failed_52",
      "formatted_type": "ai._vectorizer_q_failed_52[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 20961,
      "name": "__vectorizer_q_failed_53",
      "formatted_type": "ai._vectorizer_q_failed_53[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 20992,
      "name": "__vectorizer_q_failed_54",
      "formatted_type": "ai._vectorizer_q_failed_54[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 21023,
      "name": "__vectorizer_q_failed_55",
      "formatted_type": "ai._vectorizer_q_failed_55[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 21054,
      "name": "__vectorizer_q_failed_56",
      "formatted_type": "ai._vectorizer_q_failed_56[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1887364,
      "name": "__vectorizer_q_failed_58",
      "formatted_type": "ai._vectorizer_q_failed_58[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1887395,
      "name": "__vectorizer_q_failed_59",
      "formatted_type": "ai._vectorizer_q_failed_59[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1887426,
      "name": "__vectorizer_q_failed_60",
      "formatted_type": "ai._vectorizer_q_failed_60[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1887457,
      "name": "__vectorizer_q_failed_61",
      "formatted_type": "ai._vectorizer_q_failed_61[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1887488,
      "name": "__vectorizer_q_failed_62",
      "formatted_type": "ai._vectorizer_q_failed_62[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1887519,
      "name": "__vectorizer_q_failed_63",
      "formatted_type": "ai._vectorizer_q_failed_63[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1887550,
      "name": "__vectorizer_q_failed_71",
      "formatted_type": "ai._vectorizer_q_failed_71[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965431,
      "name": "__vectorizer_q_failed_72",
      "formatted_type": "ai._vectorizer_q_failed_72[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965462,
      "name": "__vectorizer_q_failed_73",
      "formatted_type": "ai._vectorizer_q_failed_73[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965493,
      "name": "__vectorizer_q_failed_74",
      "formatted_type": "ai._vectorizer_q_failed_74[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965524,
      "name": "__vectorizer_q_failed_75",
      "formatted_type": "ai._vectorizer_q_failed_75[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965555,
      "name": "__vectorizer_q_failed_76",
      "formatted_type": "ai._vectorizer_q_failed_76[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965586,
      "name": "__vectorizer_q_failed_77",
      "formatted_type": "ai._vectorizer_q_failed_77[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965617,
      "name": "__vectorizer_q_failed_78",
      "formatted_type": "ai._vectorizer_q_failed_78[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965648,
      "name": "__vectorizer_q_failed_79",
      "formatted_type": "ai._vectorizer_q_failed_79[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965679,
      "name": "__vectorizer_q_failed_80",
      "formatted_type": "ai._vectorizer_q_failed_80[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965710,
      "name": "__vectorizer_q_failed_81",
      "formatted_type": "ai._vectorizer_q_failed_81[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965741,
      "name": "__vectorizer_q_failed_82",
      "formatted_type": "ai._vectorizer_q_failed_82[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965772,
      "name": "__vectorizer_q_failed_83",
      "formatted_type": "ai._vectorizer_q_failed_83[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965803,
      "name": "__vectorizer_q_failed_84",
      "formatted_type": "ai._vectorizer_q_failed_84[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965834,
      "name": "__vectorizer_q_failed_85",
      "formatted_type": "ai._vectorizer_q_failed_85[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 1965865,
      "name": "__vectorizer_q_failed_86",
      "formatted_type": "ai._vectorizer_q_failed_86[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 19109,
      "name": "_feature_flag",
      "formatted_type": "ai.feature_flag[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 19101,
      "name": "_migration",
      "formatted_type": "ai.migration[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 18787,
      "name": "_pgai_lib_feature_flag",
      "formatted_type": "ai.pgai_lib_feature_flag[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 18779,
      "name": "_pgai_lib_migration",
      "formatted_type": "ai.pgai_lib_migration[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 18795,
      "name": "_pgai_lib_version",
      "formatted_type": "ai.pgai_lib_version[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 19164,
      "name": "_secret_permissions_1",
      "formatted_type": "ai.secret_permissions[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 18862,
      "name": "_semantic_catalog",
      "formatted_type": "ai.semantic_catalog[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 18876,
      "name": "_semantic_catalog_embedding",
      "formatted_type": "ai.semantic_catalog_embedding[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 18804,
      "name": "_vectorizer",
      "formatted_type": "ai.vectorizer[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 18857,
      "name": "_vectorizer_errors_1",
      "formatted_type": "ai.vectorizer_errors[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 18962,
      "name": "_vectorizer_status",
      "formatted_type": "ai.vectorizer_status[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 18826,
      "name": "_vectorizer_worker_process",
      "formatted_type": "ai.vectorizer_worker_process[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    },
    {
      "oid": 18840,
      "name": "_vectorizer_worker_progress",
      "formatted_type": "ai.vectorizer_worker_progress[]",
      "description": null,
      "kind": "b",
      "kind_label": "base"
    }
  ],
  "sequences": [
    {
      "oid": 18874,
      "name": "semantic_catalog_embedding_id_seq",
      "description": null,
      "owned_by_column": null
    },
    {
      "oid": 18860,
      "name": "semantic_catalog_id_seq",
      "description": null,
      "owned_by_column": null
    },
    {
      "oid": 18802,
      "name": "vectorizer_id_seq",
      "description": null,
      "owned_by_column": null
    }
  ],
  "views": [
    {
      "oid": 19163,
      "name": "secret_permissions",
      "definition": " SELECT name,\n    role\n   FROM ai._secret_permissions\n  WHERE to_regrole(role) IS NOT NULL AND pg_has_role(CURRENT_USER, role::name, 'member'::text);",
      "description": null
    },
    {
      "oid": 18856,
      "name": "vectorizer_errors",
      "definition": " SELECT ve.id,\n    ve.message,\n    ve.details,\n    ve.recorded,\n    v.name\n   FROM ai._vectorizer_errors ve\n     LEFT JOIN ai.vectorizer v ON ve.id = v.id;",
      "description": null
    },
    {
      "oid": 18961,
      "name": "vectorizer_status",
      "definition": " SELECT id,\n    name,\n    format('%I.%I'::text, source_schema, source_table) AS source_table,\n        CASE\n            WHEN ((config -> 'destination'::text) ->> 'implementation'::text) = 'table'::text THEN format('%I.%I'::text, (config -> 'destination'::text) ->> 'target_schema'::text, (config -> 'destination'::text) ->> 'target_table'::text)\n            ELSE NULL::text\n        END AS target_table,\n        CASE\n            WHEN ((config -> 'destination'::text) ->> 'implementation'::text) = 'table'::text THEN format('%I.%I'::text, (config -> 'destination'::text) ->> 'view_schema'::text, (config -> 'destination'::text) ->> 'view_name'::text)\n            ELSE NULL::text\n        END AS view,\n        CASE\n            WHEN ((config -> 'destination'::text) ->> 'implementation'::text) = 'column'::text THEN format('%I'::text, (config -> 'destination'::text) ->> 'embedding_column'::text)\n            ELSE 'embedding'::text\n        END AS embedding_column,\n        CASE\n            WHEN queue_table IS NOT NULL AND has_table_privilege(CURRENT_USER, format('%I.%I'::text, queue_schema, queue_table), 'select'::text) THEN ai.vectorizer_queue_pending(id)\n            ELSE NULL::bigint\n        END AS pending_items,\n    disabled\n   FROM ai.vectorizer v;",
      "description": null
    }
  ],
  "dependencies": [
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__secret_permissions",
      "referenced_type": "pg_type",
      "referenced_object": "ai._secret_permissions",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__secret_permissions",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_errors",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_errors",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_1",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_1",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_132",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_132",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_133",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_133",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_134",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_134",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_135",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_135",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_136",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_136",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_137",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_137",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_2",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_2",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_48",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_48",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_49",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_49",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_50",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_50",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_51",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_51",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_52",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_52",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_53",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_53",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_54",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_54",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_55",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_55",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_56",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_56",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_58",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_58",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_59",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_59",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_60",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_60",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_61",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_61",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_62",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_62",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_63",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_63",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_71",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_71",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_72",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_72",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_73",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_73",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_74",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_74",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_75",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_75",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_76",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_76",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_77",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_77",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_78",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_78",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_79",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_79",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_80",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_80",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_81",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_81",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_82",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_82",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_83",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_83",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_84",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_84",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_85",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_85",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_86",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_86",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_1",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_1",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_132",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_132",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_133",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_133",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_134",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_134",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_135",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_135",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_136",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_136",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_137",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_137",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_2",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_2",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_48",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_48",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_49",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_49",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_50",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_50",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_51",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_51",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_52",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_52",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_53",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_53",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_54",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_54",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_55",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_55",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_56",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_56",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_58",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_58",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_59",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_59",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_60",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_60",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_61",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_61",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_62",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_62",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_63",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_63",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_71",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_71",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_72",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_72",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_73",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_73",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_74",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_74",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_75",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_75",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_76",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_76",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_77",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_77",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_78",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_78",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_79",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_79",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_80",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_80",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_81",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_81",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_82",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_82",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_83",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_83",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_84",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_84",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_85",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_85",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.__vectorizer_q_failed_86",
      "referenced_type": "pg_type",
      "referenced_object": "ai._vectorizer_q_failed_86",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._evaluate_destination",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._evaluate_destination",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._feature_flag",
      "referenced_type": "pg_type",
      "referenced_object": "ai.feature_flag",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._feature_flag",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._migration",
      "referenced_type": "pg_type",
      "referenced_object": "ai.migration",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._migration",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._pgai_lib_feature_flag",
      "referenced_type": "pg_type",
      "referenced_object": "ai.pgai_lib_feature_flag",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._pgai_lib_migration",
      "referenced_type": "pg_type",
      "referenced_object": "ai.pgai_lib_migration",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._pgai_lib_version",
      "referenced_type": "pg_type",
      "referenced_object": "ai.pgai_lib_version",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._resolve_indexing_default",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._resolve_indexing_default",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._resolve_scheduling_default",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._resolve_scheduling_default",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._sc_obj",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._sc_obj",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._secret_permissions",
      "referenced_type": "pg_class",
      "referenced_object": "ai._secret_permissions",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._secret_permissions",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._secret_permissions",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._secret_permissions",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._secret_permissions_1",
      "referenced_type": "pg_type",
      "referenced_object": "ai.secret_permissions",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._secret_permissions_1",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._secret_permissions_pkey",
      "referenced_type": "pg_constraint",
      "referenced_object": "unknown",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._semantic_catalog",
      "referenced_type": "pg_type",
      "referenced_object": "ai.semantic_catalog",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._semantic_catalog_embedding",
      "referenced_type": "pg_type",
      "referenced_object": "ai.semantic_catalog_embedding",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._semantic_catalog_make_triggers",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._semantic_catalog_make_triggers",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_chunking",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_chunking",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_destination",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_destination",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_destination_can_create_objects",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_destination_can_create_objects",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_embedding",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_embedding",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_formatting",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_formatting",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_formatting_python_template",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_formatting_python_template",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_indexing",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_indexing",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_indexing_diskann",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_indexing_diskann",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_indexing_hnsw",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_indexing_hnsw",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_loading",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_loading",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_parsing",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_parsing",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_processing",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_processing",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_scheduling",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._validate_scheduling",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer",
      "referenced_type": "pg_type",
      "referenced_object": "ai.vectorizer",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_add_embedding_column",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_add_embedding_column",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_build_trigger_definition",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_build_trigger_definition",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_destination_column",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_destination_column",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_destination_table",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_destination_table",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_queue_failed_table",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_queue_failed_table",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_queue_table",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_queue_table",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_source_trigger",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_source_trigger",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_target_table",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_target_table",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_vector_index",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_vector_index",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_view",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_create_view",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_errors",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_errors",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_errors",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_errors_1",
      "referenced_type": "pg_type",
      "referenced_object": "ai.vectorizer_errors",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_errors_id_recorded_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_errors",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_grant_to_source",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_grant_to_source",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_grant_to_vectorizer",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_grant_to_vectorizer",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_job",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_job",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_1",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_1",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_1",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_132",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_132",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_132",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_132_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_132",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_133",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_133",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_133",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_133_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_133",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_134",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_134",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_134",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_134_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_134",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_135",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_135",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_135",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_135_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_135",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_136",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_136",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_136",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_136_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_136",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_137",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_137",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_137",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_137_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_137",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_1_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_1",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_2",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_2",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_2",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_2_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_2",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_48",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_48",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_48",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_48_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_48",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_49",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_49",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_49",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_49_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_49",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_50",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_50",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_50",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_50_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_50",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_51",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_51",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_51",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_51_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_51",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_52",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_52",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_52",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_52_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_52",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_53",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_53",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_53",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_53_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_53",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_54",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_54",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_54",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_54_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_54",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_55",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_55",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_55",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_55_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_55",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_56",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_56",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_56",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_56_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_56",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_58",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_58",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_58",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_58_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_58",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_59",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_59",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_59",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_59_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_59",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_60",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_60",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_60",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_60_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_60",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_61",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_61",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_61",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_61_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_61",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_62",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_62",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_62",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_62_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_62",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_63",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_63",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_63",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_63_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_63",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_71",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_71",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_71",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_71_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_71",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_72",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_72",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_72",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_72_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_72",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_73",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_73",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_73",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_73_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_73",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_74",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_74",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_74",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_74_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_74",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_75",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_75",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_75",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_75_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_75",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_76",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_76",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_76",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_76_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_76",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_77",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_77",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_77",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_77_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_77",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_78",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_78",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_78",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_78_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_78",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_79",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_79",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_79",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_79_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_79",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_80",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_80",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_80",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_80_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_80",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_81",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_81",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_81",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_81_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_81",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_82",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_82",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_82",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_82_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_82",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_83",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_83",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_83",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_83_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_83",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_84",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_84",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_84",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_84_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_84",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_85",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_85",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_85",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_85_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_85",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_86",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_86",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_86",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_86_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_86",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_1",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_1",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_1",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_132",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_132",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_132",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_132_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_132",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_133",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_133",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_133",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_133_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_133",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_134",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_134",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_134",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_134_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_134",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_135",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_135",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_135",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_135_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_135",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_136",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_136",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_136",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_136_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_136",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_137",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_137",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_137",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_137_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_137",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_1_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_1",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_2",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_2",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_2",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_2_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_2",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_48",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_48",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_48",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_48_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_48",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_49",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_49",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_49",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_49_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_49",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_50",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_50",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_50",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_50_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_50",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_51",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_51",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_51",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_51_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_51",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_52",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_52",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_52",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_52_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_52",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_53",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_53",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_53",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_53_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_53",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_54",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_54",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_54",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_54_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_54",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_55",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_55",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_55",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_55_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_55",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_56",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_56",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_56",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_56_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_56",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_58",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_58",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_58",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_58_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_58",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_59",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_59",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_59",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_59_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_59",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_60",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_60",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_60",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_60_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_60",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_61",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_61",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_61",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_61_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_61",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_62",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_62",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_62",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_62_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_62",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_63",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_63",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_63",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_63_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_63",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_71",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_71",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_71",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_71_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_71",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_72",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_72",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_72",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_72_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_72",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_73",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_73",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_73",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_73_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_73",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_74",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_74",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_74",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_74_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_74",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_75",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_75",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_75",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_75_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_75",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_76",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_76",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_76",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_76_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_76",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_77",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_77",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_77",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_77_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_77",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_78",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_78",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_78",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_78_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_78",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_79",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_79",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_79",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_79_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_79",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_80",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_80",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_80",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_80_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_80",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_81",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_81",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_81",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_81_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_81",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_82",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_82",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_82",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_82_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_82",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_83",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_83",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_83",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_83_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_83",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_84",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_84",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_84",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_84_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_84",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_85",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_85",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_85",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_85_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_85",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_q_failed_86",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_86",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_86",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai._vectorizer_q_failed_86_id_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_86",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_schedule_job",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_schedule_job",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_should_create_vector_index",
      "referenced_type": "pg_type",
      "referenced_object": "ai.vectorizer",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_should_create_vector_index",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_should_create_vector_index",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_source_pk",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_1",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_1",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_132",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_132",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_133",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_133",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_134",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_134",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_135",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_135",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_136",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_136",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_137",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_137",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_2",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_2",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_48",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_48",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_49",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_49",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_50",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_50",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_51",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_51",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_52",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_52",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_53",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_53",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_54",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_54",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_55",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_55",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_56",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_56",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_58",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_58",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_59",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_59",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_60",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_60",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_61",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_61",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_62",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_62",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_63",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_63",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_71",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_71",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_72",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_72",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_73",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_73",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_74",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_74",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_75",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_75",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_76",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_76",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_77",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_77",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_78",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_78",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_79",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_79",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_80",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_80",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_81",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_81",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_82",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_82",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_83",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_83",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_84",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_84",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_85",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_85",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_86",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_src_trg_86",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_status",
      "referenced_type": "pg_type",
      "referenced_object": "ai.vectorizer_status",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_vector_index_exists",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._vectorizer_vector_index_exists",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_worker_process",
      "referenced_type": "pg_type",
      "referenced_object": "ai.vectorizer_worker_process",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai._vectorizer_worker_progress",
      "referenced_type": "pg_type",
      "referenced_object": "ai.vectorizer_worker_progress",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._worker_heartbeat",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._worker_heartbeat",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._worker_progress",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._worker_progress",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._worker_start",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai._worker_start",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.anthropic_generate",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.anthropic_generate",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.anthropic_generate",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.anthropic_list_models",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.anthropic_list_models",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.anthropic_list_models",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.chunk_text",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.chunk_text",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.chunk_text",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.chunk_text_recursively",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.chunk_text_recursively",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.chunk_text_recursively",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.chunking_character_text_splitter",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.chunking_none",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.chunking_recursive_character_text_splitter",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_chat_complete",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_chat_complete",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_chat_complete",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_classify",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_classify",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_classify",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_classify_simple",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_classify_simple",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_classify_simple",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_detokenize",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_detokenize",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_detokenize",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_embed",
      "referenced_type": "pg_type",
      "referenced_object": "public.vector",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_embed",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_embed",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_embed",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_list_models",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_list_models",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_list_models",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_rerank",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_rerank",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_rerank",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_rerank_simple",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_rerank_simple",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_tokenize",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_tokenize",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.cohere_tokenize",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.create_semantic_catalog",
      "referenced_type": "pg_proc",
      "referenced_object": "ai.embedding_sentence_transformers",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.create_semantic_catalog",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.create_semantic_catalog",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.create_vectorizer",
      "referenced_type": "pg_proc",
      "referenced_object": "ai.chunking_recursive_character_text_splitter",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.create_vectorizer",
      "referenced_type": "pg_proc",
      "referenced_object": "ai.destination_table",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.create_vectorizer",
      "referenced_type": "pg_proc",
      "referenced_object": "ai.formatting_python_template",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.create_vectorizer",
      "referenced_type": "pg_proc",
      "referenced_object": "ai.grant_to",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.create_vectorizer",
      "referenced_type": "pg_proc",
      "referenced_object": "ai.indexing_default",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.create_vectorizer",
      "referenced_type": "pg_proc",
      "referenced_object": "ai.parsing_auto",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.create_vectorizer",
      "referenced_type": "pg_proc",
      "referenced_object": "ai.processing_default",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.create_vectorizer",
      "referenced_type": "pg_proc",
      "referenced_object": "ai.scheduling_default",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.create_vectorizer",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.create_vectorizer",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.destination_column",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.destination_table",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.disable_vectorizer_schedule",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.disable_vectorizer_schedule",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.drop_semantic_catalog",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.drop_semantic_catalog",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.drop_vectorizer",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.drop_vectorizer",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.embedding_litellm",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.embedding_litellm",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.embedding_ollama",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.embedding_openai",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.embedding_sentence_transformers",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.embedding_voyageai",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.embedding_voyageai",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.enable_vectorizer_schedule",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.enable_vectorizer_schedule",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.execute_vectorizer",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.execute_vectorizer",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.execute_vectorizer",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.feature_flag",
      "referenced_type": "pg_class",
      "referenced_object": "ai.feature_flag",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.feature_flag",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.feature_flag",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.feature_flag",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.feature_flag_pkey",
      "referenced_type": "pg_constraint",
      "referenced_object": "unknown",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.formatting_python_template",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.grant_ai_usage",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.grant_ai_usage",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.grant_ai_usage",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.grant_secret",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.grant_secret",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.grant_to",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.grant_vectorizer_usage",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.grant_vectorizer_usage",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.indexing_default",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.indexing_diskann",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.indexing_hnsw",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.indexing_none",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.litellm_embed",
      "referenced_type": "pg_type",
      "referenced_object": "public.vector",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.litellm_embed",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.litellm_embed",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.litellm_embed",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.load_dataset",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.load_dataset",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.load_dataset",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.load_dataset_multi_txn",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.load_dataset_multi_txn",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.load_dataset_multi_txn",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.loading_column",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.loading_uri",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.migration",
      "referenced_type": "pg_class",
      "referenced_object": "ai.migration",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.migration",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.migration",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.migration",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.migration_pkey",
      "referenced_type": "pg_constraint",
      "referenced_object": "unknown",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_chat_complete",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_chat_complete",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_chat_complete",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_embed",
      "referenced_type": "pg_type",
      "referenced_object": "public.vector",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_embed",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_embed",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_embed",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_generate",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_generate",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_generate",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_list_models",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_list_models",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_list_models",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_ps",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_ps",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.ollama_ps",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_chat_complete",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_chat_complete",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_chat_complete",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_chat_complete_simple",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_chat_complete_simple",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_chat_complete_simple",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_chat_complete_with_raw_response",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_chat_complete_with_raw_response",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_chat_complete_with_raw_response",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_client_config",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_client_config",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_client_config",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_detokenize",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_detokenize",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_detokenize",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_embed",
      "referenced_type": "pg_type",
      "referenced_object": "public.vector",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_embed",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_embed",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_embed",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_embed_with_raw_response",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_embed_with_raw_response",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_embed_with_raw_response",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_list_models",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_list_models",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_list_models",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_list_models_with_raw_response",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_list_models_with_raw_response",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_list_models_with_raw_response",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_moderate",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_moderate",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_moderate",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_moderate_with_raw_response",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_moderate_with_raw_response",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_moderate_with_raw_response",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_tokenize",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_tokenize",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.openai_tokenize",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.parsing_auto",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.parsing_docling",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.parsing_none",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.parsing_pymupdf",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.pgai_lib_feature_flag",
      "referenced_type": "pg_class",
      "referenced_object": "ai.pgai_lib_feature_flag",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.pgai_lib_feature_flag",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.pgai_lib_feature_flag_pkey",
      "referenced_type": "pg_constraint",
      "referenced_object": "unknown",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.pgai_lib_migration",
      "referenced_type": "pg_class",
      "referenced_object": "ai.pgai_lib_migration",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.pgai_lib_migration",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.pgai_lib_migration_pkey",
      "referenced_type": "pg_constraint",
      "referenced_object": "unknown",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.pgai_lib_version",
      "referenced_type": "pg_class",
      "referenced_object": "ai.pgai_lib_version",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.pgai_lib_version",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.pgai_lib_version_pkey",
      "referenced_type": "pg_constraint",
      "referenced_object": "unknown",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.processing_default",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.reveal_secret",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.reveal_secret",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.reveal_secret",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.revoke_secret",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.revoke_secret",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_add_embedding",
      "referenced_type": "pg_type",
      "referenced_object": "ai.semantic_catalog_embedding",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_add_embedding",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_add_embedding",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_add_fact",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_add_fact",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_add_sql_desc",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_add_sql_desc",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_drop_embedding",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_drop_embedding",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_grant_admin",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_grant_admin",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_grant_obj_read",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_grant_obj_read",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_grant_read",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_grant_read",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_grant_write",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_grant_write",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_set_agg_desc",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_set_func_desc",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_set_obj_desc",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_set_obj_desc",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_set_proc_desc",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_set_table_col_desc",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_set_table_desc",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_set_view_col_desc",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_set_view_desc",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_update_fact",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_update_fact",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_update_sql_desc",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.sc_update_sql_desc",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.scheduling_default",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.scheduling_none",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.scheduling_timescaledb",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.secret_permissions",
      "referenced_type": "pg_class",
      "referenced_object": "ai.secret_permissions",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.secret_permissions",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.secret_permissions",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.secret_permissions",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.semantic_catalog",
      "referenced_type": "pg_class",
      "referenced_object": "ai.semantic_catalog",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.semantic_catalog",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.semantic_catalog_catalog_name_key",
      "referenced_type": "pg_constraint",
      "referenced_object": "unknown",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.semantic_catalog_embedding",
      "referenced_type": "pg_class",
      "referenced_object": "ai.semantic_catalog_embedding",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.semantic_catalog_embedding",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.semantic_catalog_embedding_id_seq",
      "referenced_type": "pg_class",
      "referenced_object": "ai.semantic_catalog_embedding",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.semantic_catalog_embedding_id_seq",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.semantic_catalog_embedding_pkey",
      "referenced_type": "pg_constraint",
      "referenced_object": "unknown",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.semantic_catalog_embedding_semantic_catalog_id_embedding_na_key",
      "referenced_type": "pg_constraint",
      "referenced_object": "unknown",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.semantic_catalog_id_seq",
      "referenced_type": "pg_class",
      "referenced_object": "ai.semantic_catalog",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.semantic_catalog_id_seq",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.semantic_catalog_pkey",
      "referenced_type": "pg_constraint",
      "referenced_object": "unknown",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.set_scheduling",
      "referenced_type": "pg_proc",
      "referenced_object": "ai.indexing_default",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.set_scheduling",
      "referenced_type": "pg_proc",
      "referenced_object": "ai.scheduling_default",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.set_scheduling",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.set_scheduling",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.vectorizer",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.vectorizer",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.vectorizer_embed",
      "referenced_type": "pg_type",
      "referenced_object": "public.vector",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.vectorizer_embed",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.vectorizer_embed",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.vectorizer_errors",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer_errors",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.vectorizer_errors",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.vectorizer_id_seq",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.vectorizer_id_seq",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.vectorizer_name_unique",
      "referenced_type": "pg_constraint",
      "referenced_object": "unknown",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.vectorizer_pkey",
      "referenced_type": "pg_constraint",
      "referenced_object": "unknown",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.vectorizer_queue_pending",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.vectorizer_queue_pending",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.vectorizer_status",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer_status",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.vectorizer_status",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.vectorizer_worker_process",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer_worker_process",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.vectorizer_worker_process",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.vectorizer_worker_process_last_heartbeat_idx",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer_worker_process",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.vectorizer_worker_process_pkey",
      "referenced_type": "pg_constraint",
      "referenced_object": "unknown",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_type",
      "dependent_object": "ai.vectorizer_worker_progress",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer_worker_progress",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.vectorizer_worker_progress",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "ai.vectorizer_worker_progress_pkey",
      "referenced_type": "pg_constraint",
      "referenced_object": "unknown",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.voyageai_embed",
      "referenced_type": "pg_type",
      "referenced_object": "public.vector",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.voyageai_embed",
      "referenced_type": "pg_extension",
      "referenced_object": "unknown",
      "dependency_type": "e",
      "dependency_type_label": "extension"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.voyageai_embed",
      "referenced_type": "pg_language",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_proc",
      "dependent_object": "ai.voyageai_embed",
      "referenced_type": "pg_namespace",
      "referenced_object": "unknown",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_18778",
      "referenced_type": "pg_class",
      "referenced_object": "ai.pgai_lib_migration",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_18786",
      "referenced_type": "pg_class",
      "referenced_object": "ai.pgai_lib_feature_flag",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_18794",
      "referenced_type": "pg_class",
      "referenced_object": "ai.pgai_lib_version",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_18803",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_18812",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_errors",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_18825",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer_worker_process",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_18839",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer_worker_progress",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_18861",
      "referenced_type": "pg_class",
      "referenced_object": "ai.semantic_catalog",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1887363",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_58",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1887394",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_59",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1887425",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_60",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1887456",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_61",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1887487",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_62",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_18875",
      "referenced_type": "pg_class",
      "referenced_object": "ai.semantic_catalog_embedding",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1887518",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_63",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1887549",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_71",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_19038",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_1",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_19083",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_2",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_19100",
      "referenced_type": "pg_class",
      "referenced_object": "ai.migration",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_19108",
      "referenced_type": "pg_class",
      "referenced_object": "ai.feature_flag",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_19116",
      "referenced_type": "pg_class",
      "referenced_object": "ai._secret_permissions",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1965430",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_72",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1965461",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_73",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1965492",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_74",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1965523",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_75",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1965554",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_76",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1965585",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_77",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1965616",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_78",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1965647",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_79",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1965678",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_80",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1965709",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_81",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1965740",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_82",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1965771",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_83",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1965802",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_84",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1965833",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_85",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1965864",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_86",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1974284",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_132",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1974315",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_133",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1974346",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_134",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1974377",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_135",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1974408",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_136",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_1974439",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_137",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_20805",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_48",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_20836",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_49",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_20867",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_50",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_20898",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_51",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_20929",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_52",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_20960",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_53",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_20991",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_54",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_21022",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_55",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_class",
      "dependent_object": "pg_toast.pg_toast_21053",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_56",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._secret_permissions",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._secret_permissions",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_rewrite",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._secret_permissions",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_errors",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_errors",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_rewrite",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_errors",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_1",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_132",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_133",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_134",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_135",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_136",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_137",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_2",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_48",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_49",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_50",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_51",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_52",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_53",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_54",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_55",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_56",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_58",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_59",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_60",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_61",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_62",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_63",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_71",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_72",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_73",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_74",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_75",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_76",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_77",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_78",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_79",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_80",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_81",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_82",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_83",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_84",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_85",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_86",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_1",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_132",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_133",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_134",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_135",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_136",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_137",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_2",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_48",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_49",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_50",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_51",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_52",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_53",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_54",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_55",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_56",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_58",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_59",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_60",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_61",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_62",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_63",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_71",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_72",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_73",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_74",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_75",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_76",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_77",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_78",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_79",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_80",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_81",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_82",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_83",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_84",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_85",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai._vectorizer_q_failed_86",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_1",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_132",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_133",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_134",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_135",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_136",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_137",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_2",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_48",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_49",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_50",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_51",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_52",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_53",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_54",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_55",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_56",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_58",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_59",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_60",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_61",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_62",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_63",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_71",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_72",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_73",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_74",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_75",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_76",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_77",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_78",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_79",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_80",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_81",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_82",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_83",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_84",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_85",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_trigger",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai._vectorizer_src_trg_86",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.feature_flag",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.feature_flag",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.migration",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.migration",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.pgai_lib_feature_flag",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.pgai_lib_feature_flag",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.pgai_lib_migration",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.pgai_lib_migration",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.pgai_lib_version",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.pgai_lib_version",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_rewrite",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.secret_permissions",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.semantic_catalog",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.semantic_catalog",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.semantic_catalog_embedding",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.semantic_catalog_embedding",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.semantic_catalog_pkey",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_rewrite",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_rewrite",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer_errors",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer_pkey",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_rewrite",
      "dependent_object": "unknown",
      "referenced_type": "pg_proc",
      "referenced_object": "ai.vectorizer_queue_pending",
      "dependency_type": "n",
      "dependency_type_label": "normal"
    },
    {
      "dependent_type": "pg_rewrite",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer_status",
      "dependency_type": "i",
      "dependency_type_label": "internal"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer_worker_process",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer_worker_process",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_attrdef",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer_worker_progress",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    },
    {
      "dependent_type": "pg_constraint",
      "dependent_object": "unknown",
      "referenced_type": "pg_class",
      "referenced_object": "ai.vectorizer_worker_progress",
      "dependency_type": "a",
      "dependency_type_label": "auto"
    }
  ],
  "tables": [
    {
      "oid": 19116,
      "name": "_secret_permissions",
      "description": null,
      "estimated_rows": -1,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 18812,
      "name": "_vectorizer_errors",
      "description": null,
      "estimated_rows": -1,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 19032,
      "name": "_vectorizer_q_1",
      "description": null,
      "estimated_rows": -1,
      "total_size": "24 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1974278,
      "name": "_vectorizer_q_132",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1974309,
      "name": "_vectorizer_q_133",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1974340,
      "name": "_vectorizer_q_134",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1974371,
      "name": "_vectorizer_q_135",
      "description": null,
      "estimated_rows": 15,
      "total_size": "64 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1974402,
      "name": "_vectorizer_q_136",
      "description": null,
      "estimated_rows": 15,
      "total_size": "64 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1974433,
      "name": "_vectorizer_q_137",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 19077,
      "name": "_vectorizer_q_2",
      "description": null,
      "estimated_rows": -1,
      "total_size": "8192 bytes",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 20799,
      "name": "_vectorizer_q_48",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 20830,
      "name": "_vectorizer_q_49",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 20861,
      "name": "_vectorizer_q_50",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 20892,
      "name": "_vectorizer_q_51",
      "description": null,
      "estimated_rows": 15,
      "total_size": "64 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 20923,
      "name": "_vectorizer_q_52",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 20954,
      "name": "_vectorizer_q_53",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 20985,
      "name": "_vectorizer_q_54",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 21016,
      "name": "_vectorizer_q_55",
      "description": null,
      "estimated_rows": 15,
      "total_size": "64 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 21047,
      "name": "_vectorizer_q_56",
      "description": null,
      "estimated_rows": 15,
      "total_size": "64 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1887357,
      "name": "_vectorizer_q_58",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1887388,
      "name": "_vectorizer_q_59",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1887419,
      "name": "_vectorizer_q_60",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1887450,
      "name": "_vectorizer_q_61",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1887481,
      "name": "_vectorizer_q_62",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1887512,
      "name": "_vectorizer_q_63",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1887543,
      "name": "_vectorizer_q_71",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965424,
      "name": "_vectorizer_q_72",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965455,
      "name": "_vectorizer_q_73",
      "description": null,
      "estimated_rows": 15,
      "total_size": "64 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965486,
      "name": "_vectorizer_q_74",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965517,
      "name": "_vectorizer_q_75",
      "description": null,
      "estimated_rows": 15,
      "total_size": "64 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965548,
      "name": "_vectorizer_q_76",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965579,
      "name": "_vectorizer_q_77",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965610,
      "name": "_vectorizer_q_78",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965641,
      "name": "_vectorizer_q_79",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965672,
      "name": "_vectorizer_q_80",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965703,
      "name": "_vectorizer_q_81",
      "description": null,
      "estimated_rows": 15,
      "total_size": "64 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965734,
      "name": "_vectorizer_q_82",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965765,
      "name": "_vectorizer_q_83",
      "description": null,
      "estimated_rows": 0,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965796,
      "name": "_vectorizer_q_84",
      "description": null,
      "estimated_rows": 15,
      "total_size": "64 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965827,
      "name": "_vectorizer_q_85",
      "description": null,
      "estimated_rows": 15,
      "total_size": "64 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965858,
      "name": "_vectorizer_q_86",
      "description": null,
      "estimated_rows": 15,
      "total_size": "64 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 19038,
      "name": "_vectorizer_q_failed_1",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1974284,
      "name": "_vectorizer_q_failed_132",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1974315,
      "name": "_vectorizer_q_failed_133",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1974346,
      "name": "_vectorizer_q_failed_134",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1974377,
      "name": "_vectorizer_q_failed_135",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1974408,
      "name": "_vectorizer_q_failed_136",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1974439,
      "name": "_vectorizer_q_failed_137",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 19083,
      "name": "_vectorizer_q_failed_2",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 20805,
      "name": "_vectorizer_q_failed_48",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 20836,
      "name": "_vectorizer_q_failed_49",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 20867,
      "name": "_vectorizer_q_failed_50",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 20898,
      "name": "_vectorizer_q_failed_51",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 20929,
      "name": "_vectorizer_q_failed_52",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 20960,
      "name": "_vectorizer_q_failed_53",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 20991,
      "name": "_vectorizer_q_failed_54",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 21022,
      "name": "_vectorizer_q_failed_55",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 21053,
      "name": "_vectorizer_q_failed_56",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1887363,
      "name": "_vectorizer_q_failed_58",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1887394,
      "name": "_vectorizer_q_failed_59",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1887425,
      "name": "_vectorizer_q_failed_60",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1887456,
      "name": "_vectorizer_q_failed_61",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1887487,
      "name": "_vectorizer_q_failed_62",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1887518,
      "name": "_vectorizer_q_failed_63",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1887549,
      "name": "_vectorizer_q_failed_71",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965430,
      "name": "_vectorizer_q_failed_72",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965461,
      "name": "_vectorizer_q_failed_73",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965492,
      "name": "_vectorizer_q_failed_74",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965523,
      "name": "_vectorizer_q_failed_75",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965554,
      "name": "_vectorizer_q_failed_76",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965585,
      "name": "_vectorizer_q_failed_77",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965616,
      "name": "_vectorizer_q_failed_78",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965647,
      "name": "_vectorizer_q_failed_79",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965678,
      "name": "_vectorizer_q_failed_80",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965709,
      "name": "_vectorizer_q_failed_81",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965740,
      "name": "_vectorizer_q_failed_82",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965771,
      "name": "_vectorizer_q_failed_83",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965802,
      "name": "_vectorizer_q_failed_84",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965833,
      "name": "_vectorizer_q_failed_85",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 1965864,
      "name": "_vectorizer_q_failed_86",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 19108,
      "name": "feature_flag",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 19100,
      "name": "migration",
      "description": null,
      "estimated_rows": -1,
      "total_size": "48 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 18786,
      "name": "pgai_lib_feature_flag",
      "description": null,
      "estimated_rows": -1,
      "total_size": "16 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 18778,
      "name": "pgai_lib_migration",
      "description": null,
      "estimated_rows": -1,
      "total_size": "72 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 18794,
      "name": "pgai_lib_version",
      "description": null,
      "estimated_rows": -1,
      "total_size": "32 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 18861,
      "name": "semantic_catalog",
      "description": null,
      "estimated_rows": -1,
      "total_size": "24 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 18875,
      "name": "semantic_catalog_embedding",
      "description": null,
      "estimated_rows": -1,
      "total_size": "24 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 18803,
      "name": "vectorizer",
      "description": null,
      "estimated_rows": -1,
      "total_size": "144 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 18825,
      "name": "vectorizer_worker_process",
      "description": null,
      "estimated_rows": 4,
      "total_size": "296 kB",
      "kind": "r",
      "kind_label": "table"
    },
    {
      "oid": 18839,
      "name": "vectorizer_worker_progress",
      "description": null,
      "estimated_rows": 26,
      "total_size": "64 kB",
      "kind": "r",
      "kind_label": "table"
    }
  ]
}